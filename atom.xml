<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tangminjie.github.io</id>
    <title>Tangminjie Blog</title>
    <updated>2022-04-18T10:46:37.621Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tangminjie.github.io"/>
    <link rel="self" href="https://tangminjie.github.io/atom.xml"/>
    <logo>https://tangminjie.github.io/images/avatar.png</logo>
    <icon>https://tangminjie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Tangminjie Blog</rights>
    <entry>
        <title type="html"><![CDATA[表达式和控制结构]]></title>
        <id>https://tangminjie.github.io/post/biao-da-shi-he-kong-zhi-jie-gou/</id>
        <link href="https://tangminjie.github.io/post/biao-da-shi-he-kong-zhi-jie-gou/">
        </link>
        <updated>2022-04-18T09:47:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="控制结构">控制结构</h2>
<p>JavaScript 中的大部分控制结构在 Solidity 中都是可用的，除了 switch 和 goto。 因此 Solidity 中有 if，else，while，do，for，break，continue，return，? : 这些与在 C 或者 JavaScript 中表达相同语义的关键词。<br>
Solidity还支持 try/catch 语句形式的异常处理， 但仅用于 外部函数调用　和　合约创建调用．<br>
注意：与 C 和 JavaScript 不同， Solidity 中非布尔类型数值不能转换为布尔类型，因此 if (1) { ... } 的写法在 Solidity 中 无效 。</p>
<h2 id="函数调用">函数调用</h2>
<p>当前合约中的函数可以直接（“从内部”）调用，这些函数调用在 EVM 中被解释为简单的跳转。</p>
<h2 id="外部函数调用">外部函数调用</h2>
<p>表达式 this.g(8); 和 c.g(2); （其中 c 是合约实例）也是有效的函数调用，但是这种情况下，函数将会通过一个消息调用来进行“外部调用”，而不是直接的跳转。 请注意，不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。<br>
当调用其他合约的函数时，随函数调用发送的 Wei 和 gas 的数量可以分别由特定选项　{value: 10, gas: 10000}<br>
请注意，不建议明确指定gas，因为操作码的gas 消耗将来可能会发生变化。 任何发送给合约 Wei 将被添加到该合约的总余额中：</p>
<pre><code class="language-pragma">
contract InfoFeed {
    function info() public payable returns (uint ret) { return 42; }
}

contract Consumer {
    InfoFeed feed;
    function setFeed(InfoFeed addr) public { feed = addr; }
    function callFeed() public { feed.info{value: 10, gas: 800}(); }
}
//payable 修饰符要用于修饰 info 函数，否则，value 选项将不可用。
</code></pre>
<h2 id="具名调用和匿名函数参数">具名调用和匿名函数参数</h2>
<p>函数调用参数也可以按照任意顺序由名称给出，如果它们被包含在 { } 中， 如以下示例中所示。参数列表必须按名称与函数声明中的参数列表相符，但可以按任意顺序排列。</p>
<pre><code class="language-pragma">
contract C {
    mapping(uint =&gt; uint) data;

    function f() public {
        set({value: 2, key: 3});
    }

    function set(uint key, uint value) public {
        data[key] = value;
    }

}
</code></pre>
<h2 id="省略函数参数名称">省略函数参数名称</h2>
<p>未使用参数的名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问</p>
<pre><code class="language-pragma">
contract C {
    // 省略参数名称
    function func(uint k, uint) public pure returns(uint) {
        return k;
    }
}
</code></pre>
<h2 id="通过-new-创建合约">通过 new 创建合约</h2>
<p>使用关键字 new 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。</p>
<pre><code class="language-pragma">
contract D {
    uint x;
    function D(uint a) payable {
        x = a;
    }
}

contract C {
    D d = new D(4); // 将作为合约 C 构造函数的一部分执行

    function createD(uint arg) public {
        D newD = new D(arg);
    }

    function createAndEndowD(uint arg, uint amount) public payable {
                //随合约的创建发送 ether
        D newD = (new D){value:amount}(arg);  
    }
}
//通过使用 value 选项创建 D 的实例时可以附带发送 Ether，但是不能限制 gas 的数量。 如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。
</code></pre>
<h2 id="加盐的合约创建-create2">加“盐”的合约创建 create2</h2>
<p>在创建合约时，将根据创建合约的地址和每次创建合约交易时的计数器(nonce)来计算合约的地址。<br>
如果你指定了一个可选的 <code>salt</code>（一个bytes32值），那么合约创建将使用另一种机制来生成新合约的地址：<br>
它将根据给定的盐值，创建合约的字节码和构造函数参数来计算创建合约的地址。地址计算公式如下：</p>
<pre><code class="language-keccak256">address— 调用CREATE2的智能合约的地址
salt— 随机数,其实是确定的比如用userId计算出的哈希
init_code— 要部署合约的字节码
</code></pre>
<p>特别注意，不使用计数器（“nonce”）。 这样可以在创建合约时提供更大的灵活性：你可以在创建新合约之前就推导出（将要创建的）合约地址。甚至是，还可以依赖此地址（即便它还不存在）来创建其他合约。一个主要用例场景是充当链下交互仲裁合约，仅在有争议时才需要创建。</p>
<pre><code class="language-//">pragma solidity ^0.7.0;

contract D {
   uint public x;
   constructor(uint a) {
       x = a;
   }
}

contract C {
   function createDSalted(bytes32 salt, uint arg) public {
       /// 这个复杂的表达式只是告诉我们，如何预先计算地址。
       /// 这里仅仅用来说明。
       /// 实际上，你仅仅需要 ``new D{salt: salt}(arg)``.
       address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(
           bytes1(0xff),
           address(this),
           salt,
           keccak256(abi.encodePacked(
               type(D).creationCode,
               arg
           ))
       )))));

       D d = new D{salt: salt}(arg);
       require(address(d) == predictedAddress);
   }
}
</code></pre>
<h2 id="表达式计算顺序">表达式计算顺序</h2>
<h2 id="赋值">赋值</h2>
<h4 id="解构赋值和返回多值">解构赋值和返回多值</h4>
<pre><code class="language-ragma">
contract C {
    uint index;

    function f() public pure returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        //基于返回的元组来声明变量并赋值
        (uint x, bool b, uint y) = f();
        //交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。
        (x, y) = (y, x);
        //元组的末尾元素可以省略（这也适用于变量声明）。
        (index,,) = f(); // 设置 index 为 7
    }
}
</code></pre>
<h4 id="数组和结构体的复杂性">数组和结构体的复杂性</h4>
<p>在下面的示例中, 对 g(x) 的调用对 x 没有影响, 因为它在内存中创建了存储值独立副本。但是, h(x) 成功修改 x , 因为只传递引用而不传递副本。</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.22 &lt;0.9.0;

 contract C {
    uint[20] x;

     function f() public {
        g(x);
        h(x);
    }

     function g(uint[20] memory y) internal pure {
        y[2] = 3;
    }

     function h(uint[20] storage y) internal {
        y[3] = 4;
    }
}
</code></pre>
<h2 id="作用域和声明">作用域和声明</h2>
<p>Solidity 中的作用域规则遵循了 C99（与其他很多语言一样）：变量将会从它们被声明之后可见，直到一对 { } 块的结束。作为一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 for 循环的结束。</p>
<h2 id="算术运算的检查模式与非检查模式">算术运算的检查模式与非检查模式</h2>
<p>当对无限制整数执行算术运算，其结果超出结果类型的范围，这是就发生了上溢出或下溢出。<br>
在Solidity 0.8.0之前，算术运算总是会在发生溢出的情况下进行“截断”，从而得靠引入额外检查库来解决这个问题（如 OpenZepplin 的 SafeMath）。<br>
而从Solidity 0.8.0开始，所有的算术运算默认就会进行溢出检查，额外引入库将不再必要。<br>
如果想要之前“截断”的效果，可以使用 unchecked 代码块：</p>
<pre><code class="language-//">pragma solidity &gt;0.7.99;
contract C {
    function f(uint a, uint b) pure public returns (uint) {
        // 溢出会返回“截断”的结果
        unchecked { return a - b; }
    }
    function g(uint a, uint b) pure public returns (uint) {
        // 溢出会抛出异常
        return a - b;
    }
}
</code></pre>
<h2 id="错误处理及异常assert-require-revert">错误处理及异常：Assert, Require, Revert</h2>
<p>同样作为判断一个条件是否满足的函数，require会退回剩下的gas，而assert会烧掉所有的gas。require 常用来执行条件判断，作为函数执行的一个合理的判断。assert常用来中断函数，抛出异常。一般来说正常运行的函数不会运行到assert。<br>
revert会撤回所有的状态转变。但是它有两点不同：</p>
<ol>
<li>它允许你返回一个值；</li>
<li>它会把所有剩下的gas退回给caller</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单位和全局变量]]></title>
        <id>https://tangminjie.github.io/post/dan-wei-he-quan-ju-bian-liang/</id>
        <link href="https://tangminjie.github.io/post/dan-wei-he-quan-ju-bian-liang/">
        </link>
        <updated>2022-04-18T09:00:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="以太币ether-单位">以太币Ether 单位</h2>
<pre><code class="language-assert(1">assert(1 gwei == 1e9);
assert(1 ether == 1e18);
</code></pre>
<h2 id="时间单位">时间单位</h2>
<p>秒是缺省时间单位，在时间单位之间，数字后面带有 seconds、 minutes、 hours、 days 和 weeks 的可以进行换算，基本换算关系如下：</p>
<pre><code class="language-1">1 minutes == 60 seconds
1 hours == 60 minutes
1 days == 24 hours
1 weeks == 7 days
</code></pre>
<p>注意：years 已经在 0.5.0 版本去除了，因为闰年的原因。</p>
<pre><code class="language-function">    if (block.timestamp &gt;= start + daysAfter * 1 days) {
        // ...
    }
}
</code></pre>
<h2 id="特殊变量和函数">特殊变量和函数</h2>
<p>在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。<br>
<strong>区块和交易属性</strong></p>
<pre><code class="language-blockhash(uint">block.chainid (uint): 当前链 id
block.coinbase ( address ): 挖出当前区块的矿工地址
block.difficulty ( uint ): 当前区块难度
block.gaslimit ( uint ): 当前区块 gas 限额
block.number ( uint ): 当前区块号
block.timestamp ( uint): 自 unix epoch 起始当前区块以秒计的时间戳
gasleft() returns (uint256) ：剩余的 gas
msg.data ( bytes ): 完整的 calldata
msg.sender ( address ): 消息发送者（当前调用）
msg.sig ( bytes4 ): calldata 的前 4 字节（也就是函数标识符）
msg.value ( uint ): 随消息发送的 wei 的数量
tx.gasprice (uint): 交易的 gas 价格
tx.origin (address payable): 交易发起者（完全的调用链）
</code></pre>
<h2 id="abi-编码及解码函数">ABI 编码及解码函数</h2>
<pre><code class="language-abi.decode(bytes">abi.encode(...) returns (bytes)： ABI - 对给定参数进行编码
abi.encodePacked(...) returns (bytes)：对给定参数执行 紧打包编码 ，注意，可以不明确打包编码。
abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)： ABI - 对给定第二个开始的参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回
abi.encodeWithSignature(string signature, ...) returns (bytes)：等价于 abi.encodeWithSelector(bytes4(keccak256(signature), ...)
</code></pre>
<h2 id="错误处理">错误处理</h2>
<p>assert(bool condition) 如果不满足条件，则会导致 Panic 错误，则撤销状态更改 - 用于检查内部错误。<br>
require(bool condition) 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。<br>
require(bool condition, string memory message) 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。<br>
revert() 终止运行并撤销状态更改。<br>
revert(string memory reason) 终止运行并撤销状态更改，可以同时提供一个解释性的字符串。<br>
注意：assert 不返回gas费用，require返回gas费用。revert()会回滚所有状态，并且返回剩余gas</p>
<h2 id="数学和密码学函数">数学和密码学函数</h2>
<p>1.addmod(uint x, uint y, uint k) returns (uint)<br>
计算 (x + y) % k，加法会在任意精度下执行，并且加法的结果即使超过 2<strong>256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。<br>
2.mulmod(uint x, uint y, uint k) returns (uint)<br>
计算 (x * y) % k，乘法会在任意精度下执行，并且乘法的结果即使超过 2</strong>256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。<br>
3.keccak256((bytes memory) returns (bytes32)<br>
计算 Keccak-256 哈希。<br>
4.sha256(bytes memory) returns (bytes32)<br>
计算参数的 SHA-256 哈希。<br>
5.ripemd160(bytes memory) returns (bytes20)<br>
计算参数的 RIPEMD-160 哈希。<br>
6.ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)<br>
利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。ecrecover 返回一个 address, 而不是 address payable 。他们之前的转换参考 address payable ，如果需要转移资金到恢复的地址。</p>
<h2 id="地址成员">地址成员</h2>
<pre><code class="language-&lt;address&gt;.balance">以 Wei 为单位的 地址类型 Address 的余额。
&lt;address&gt;.code (bytes memory)
在 地址类型 Address 上的代码(可以为空)
&lt;address&gt;.codehash (bytes32)
:ref:`address`的codehash
&lt;address payable&gt;.transfer(uint256 amount)
向 地址类型 Address 发送数量为 amount 的 Wei，失败时抛出异常，使用固定（不可调节）的 2300 gas 的矿工费。
&lt;address payable&gt;.send(uint256 amount) returns (bool)
向 地址类型 Address 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。
&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)
用给定的有效载荷（payload）发出低级 CALL 调用，返回成功状态及返回数据，发送所有可用 gas，也可以调节 gas。
&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)
用给定的有效载荷 发出低级 DELEGATECALL 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。 发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。
&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)
用给定的有效载荷 发出低级 STATICCALL 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。
</code></pre>
<h2 id="合约相关">合约相关</h2>
<p>1.this (当前的合约类型) 当前合约，可以显示转换为 地址类型 Address。<br>
2.selfdestruct(address payable recipient) 销毁合约，并把余额发送到指定 地址类型 Address</p>
<h2 id="类型信息">类型信息</h2>
<p>表达式 type(X) 可用于检索参数 X 的类型信息。 目前，此功能还比较有限( X 仅能是合约和整型)，但是未来应该会扩展。</p>
<p>用于合约类型 C 支持以下属性:</p>
<pre><code class="language-type(C).name">type(C).creationCode        //获得包含创建合约字节码的内存字节数组
type(C).runtimeCode         //获得合约运行时字节码的内存字节数组
type(I).interfaceId             //返回接口``I`` 的 bytes4 类型的接口 ID
type(T).min                        //返回整型T的最小值
type(T).max                        //返回整型T的最大值
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类型]]></title>
        <id>https://tangminjie.github.io/post/solidity-leixing/</id>
        <link href="https://tangminjie.github.io/post/solidity-leixing/">
        </link>
        <updated>2022-04-17T15:49:30.000Z</updated>
        <content type="html"><![CDATA[<p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。<br>
Solidity 提供了几种基本类型，并且基本类型可以用来组合出复杂类型。<br>
<strong>需要注意以下几点:</strong><br>
1.“undefined”或“null”值的概念在Solidity中不存在。<br>
2.变量声明后将有默认初始值，其初始值字节表示全部为零。<br>
3.bool 类型的默认值是 false。<br>
4.uint 或 int 类型的默认值是 0 。<br>
5.静态大小的数组和 bytes1 到 bytes32 ，每个单独的元素将被初始化为与其类型相对应的默认值。<br>
6.对于动态大小的数组 bytes 和 string 类型，其默认缺省值是一个空数组或空字符串。<br>
7.对于 enum 类型, 默认值是第一个成员。</p>
<h2 id="值类型">值类型</h2>
<h4 id="布尔类型">布尔类型</h4>
<p>bool：可能的取值为字面常量值 true 和 false 。</p>
<h4 id="整型">整型</h4>
<p>int / uint ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 uint8 到 uint256 （无符号，从 8 位到 256 位）以及 int8 到 int256，以 8 位为步长递增。 uint 和 int 分别是 uint256 和 int256 的别名。<br>
<strong>警告</strong><br>
Solidity中的整数是有取值范围的。 例如 uint32 类型的取值范围是 0 到 2 ** 32-1 。 0.8.0 开始，算术运算有两个计算模式：一个是 “wrapping”（截断）模式或称 “unchecked”（不检查）模式，一个是”checked” （检查）模式。 默认情况下，算术运算在 “checked” 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。 你也可以通过 <code>unchecked { ... }</code> 切换到 “unchecked”模式，更多可参考 unchecked .</p>
<h4 id="定长浮点型">定长浮点型</h4>
<p><strong>警告</strong><br>
Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。<br>
fixed / ufixed：表示各种大小的有符号和无符号的定长浮点型。 在关键字 ufixedMxN 和 fixedMxN 中，M 表示该类型占用的位数，N 表示可用的小数位数。 M 必须能整除 8，即 8 到 256 位。 N 则可以是从 0 到 80 之间的任意数。 ufixed 和 fixed 分别是 ufixed128x19 和 fixed128x19 的别名。</p>
<h4 id="地址类型-address">地址类型 Address</h4>
<p>地址类型有两种形式，他们大致相同：<br>
1.address：保存一个20字节的值（以太坊地址的大小）。<br>
2.address payable ：可支付地址，与 address 相同，不过有成员函数 transfer 和 send 。<br>
这种区别背后的思想是 address payable 可以接受以太币的地址，而一个普通的 address 则不能。<br>
<strong>类型转换:</strong><br>
允许从 address payable 到 address 的隐式转换，而从 address 到 address payable 必须显示的转换, 通过<code>payable(&lt;address&gt;)</code> 进行转换。<br>
address 允许和 uint160、 整型字面常量、bytes20 及合约类型相互转换。<br>
只能通过 payable(...) 表达式把 address 类型和合约类型转换为 address payable。 只有能接收以太币的合约类型，才能够进行此转换。例如合约要么有 receive 或可支付的fallback函数。 注意 payable(0) 是有效的，这是此规则的例外。<br>
<strong>地址类型成员变量</strong><br>
<strong>balance 和 transfer</strong><br>
可以使用 balance 属性来查询一个地址的余额， 也可以使用 transfer 函数向一个可支付地址（payable address）发送 以太币Ether （以 wei 为单位）：</p>
<pre><code class="language-address">address myAddress = this;
if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);
</code></pre>
<p>如果当前合约的余额不够多，则 transfer 函数会执行失败，或者如果以太转移被接收帐户拒绝， transfer 函数同样会失败而进行回退。<br>
<strong>注意</strong><br>
如果 x 是一个合约地址，它的代码（更具体来说是, 如果有receive函数, 执行 receive 接收以太函数, 或者存在fallback函数,执行 Fallback 回退函数 函数）会跟 transfer 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。<br>
当然因为这个特性的存在，我们在设计合约的时候需要考虑到可重入攻击（利用transfer执行之后回调用fallback进入递归反复转账）<br>
<strong>send</strong><br>
send 是 transfer 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 send 会返回 false。<br>
<strong>注意</strong><br>
send 是 transfer 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 send 会返回 false。在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证 以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用接收者自己取回资金的模式。<br>
<strong>call， delegatecall 和 staticcall</strong><br>
为了与不符合 应用二进制接口Application Binary Interface(ABI) 的合约交互，或者要更直接地控制编码，提供了函数 call，delegatecall 和 staticcall 。 它们都带有一个 bytes memory 参数和返回执行成功状态（bool）和数据（bytes memory）。<br>
函数 abi.encode，abi.encodePacked，abi.encodeWithSelector 和 abi.encodeWithSignature 可用于编码结构化数据。</p>
<pre><code class="language-bytes">(bool success, bytes memory returnData) = address(nameReg).call(payload);
require(success);
</code></pre>
<p>此外，为了与不符合 应用二进制接口Application Binary Interface(ABI) 的合约交互，于是就有了可以接受任意类型任意数量参数的 call 函数。 这些参数会被打包到以 32 字节为单位的连续区域中存放。 其中一个例外是当第一个参数被编码成正好 4 个字节的情况。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。</p>
<pre><code class="language-address">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);
nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);
</code></pre>
<p>可以使用gas修改器，调整提供的 gas 数量，也能控制提供的 以太币Ether 的值。 修改器modifier 可以联合使用。每个修改器出现的顺序不重要。</p>
<pre><code class="language-address(nameReg).call{gas:"></code></pre>
<p>以类似的方式，可以使用函数 delegatecall ：区别在于只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。 delegatecall 的目的是使用另一个合约中的库代码。 用户必须确保两个合约中的存储结构都适合委托调用 （delegatecall）。</p>
<h4 id="合约类型">合约类型</h4>
<p>1.只有当合约具有 接收receive函数 或 payable 回退函数时，才能显式和 address payable 类型相互转换 转换仍然使用 address(x) 执行， 如果合约类型没有接收或payable 回退功能，则可以使用 payable(address(x)) 转换为 address payable 。<br>
2,.您还可以实例化合约（即新创建一个合约对象）,使用new创建合约。<br>
3.合约类型的成员是合约的外部函数及 public 的 状态变量。<br>
4.对于合约 C 可以使用 type(C) 获取合约的类型信息，</p>
<h4 id="定长字节数组">定长字节数组</h4>
<p>关键字有：bytes1， bytes2， bytes3， …， bytes32。<br>
成员变量：.length 表示这个字节数组的长度（只读）.<br>
可以将 byte[] 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 bytes。</p>
<h4 id="边长字节数组">边长字节数组</h4>
<h4 id="地址字面常量">地址字面常量</h4>
<h4 id="有理数和整数字面常量">有理数和整数字面常量</h4>
<h4 id="字符串字面常量及类型">字符串字面常量及类型</h4>
<h4 id="unicode-字面常量">Unicode 字面常量</h4>
<p>常规字符串文字只能包含ASCII，而Unicode文字（以关键字unicode为前缀）可以包含任何有效的UTF-8序列。 它们还支持与转义序列完全相同的字符作为常规字符串文字。</p>
<pre><code class="language-string"></code></pre>
<h4 id="十六进制字面常量">十六进制字面常量</h4>
<h4 id="枚举类型">枚举类型</h4>
<p>枚举是在Solidity中创建用户定义类型的一种方法。 它们是显示所有整型相互转换，但不允许隐式转换。 从整型显式转换枚举，会在运行时检查整数时候在枚举范围内，否则会导致异常（ Panic异常 ）。 枚举需要至少一个成员,默认值是第一个成员，枚举不能多于 256 个成员。<br>
数据表示与C中的枚举相同：选项从“0”开始的无符号整数值表示。</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.16  &lt;0.9.0;

contract test {
    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
    ActionChoices choice;
    ActionChoices constant defaultChoice = ActionChoices.GoStraight;

    function setGoStraight() public {
        choice = ActionChoices.GoStraight;
    }

    // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，
    // &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。

    function getChoice() public view returns (ActionChoices) {
        return choice;
    }

    function getDefaultChoice() public pure returns (uint) {
        return uint(defaultChoice);
    }
}
</code></pre>
<h4 id="函数类型">函数类型</h4>
<p>1.内部（internal） 函数类型，外部（external） 函数类型，公共函数（public），私有函数（private），函数类型默认是内部函数，因此不需要声明 internal 关键字<br>
2.类型转换：<br>
pure 函数可以转换为 view 和 non-payable 函数<br>
view 函数可以转换为 non-payable 函数<br>
payable 函数可以转换为 non-payable 函数，其他的转换则不可以。<br>
3.public（或 external）函数都有下面的成员：<br>
.address 返回函数的合约地址。<br>
.selector 返回 ABI 函数选择器</p>
<h2 id="引用类型">引用类型</h2>
<p>1.memory 内存即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。<br>
2.存储 storage 状态变量保存的位置，只要合约存在就一直存储．<br>
3.调用数据 calldata 用来保存函数参数的特殊数据位置，是一个只读位置。</p>
<h4 id="数据位置">数据位置</h4>
<h4 id="数据位置与赋值行为">数据位置与赋值行为</h4>
<p>1.在存储storage和内存memory 之间两两赋值（或者从 调用数据calldata 赋值 ），都会创建一份独立的拷贝。<br>
2.从内存memory到内存memory 的赋值只创建引用， 这意味着更改内存变量，其他引用相同数据的所有其他内存变量的值也会跟着改变。<br>
3.从 存储storage 到本地存储变量的赋值也只分配一个引用。<br>
4.其他的向 存储storage 的赋值，总是进行拷贝。 这种情况的示例如对状态变量或 存储storage 的结构体类型的局部变量成员的赋值，即使局部变量本身是一个引用，也会进行一份拷贝。</p>
<h4 id="数组">数组</h4>
<p>1.一个元素类型为 T，固定长度为 k 的数组可以声明为 T[k]，而动态数组声明为 T[]。<br>
2.一个长度为 5，元素类型为 uint 的动态数组的数组（二维数组），应声明为 uint[][5]</p>
<h4 id="创建内存数组">创建内存数组</h4>
<p>1.不能 通过修改成员变量 .push 改变 内存 memory 数组的大小<br>
2.定长的 内存memory 数组并不能赋值给变长的 内存memory 数组<br>
3.</p>
<pre><code class="language-pragma">
contract TX {
    function f(uint len) public pure {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);

        assert(a.length == 7);
        assert(b.length == len);

        a[6] = 8;
    }
}
</code></pre>
<h4 id="数组成员">数组成员</h4>
<p>1.length<br>
2.push() x.push().t = 2 或 x.push() = b<br>
3.push(x) 固定 gas 费用<br>
4.pop 根据现有的数组长度和移除的个数收取 gas 费用</p>
<h4 id="数组切片">数组切片</h4>
<p>1.数组切片是数组连续部分的视图，用法如：x[start:end] ， start 和 end 是 uint256 类型（或结果为 uint256 的表达式）。 x[start:end] 的第一个元素是 x[start] ， 最后一个元素是 x[end - 1] 。<br>
2.目前数组切片，仅可使用于 calldata 数组.</p>
<h4 id="结构体">结构体</h4>
<p>1.和大多数编程语言一样，结构体类型可以作为元素用在映射和数组中，其自身也可以包含映射和数组作为成员变量。<br>
2.在合约外部声明结构体可以使其被多个合约共享。</p>
<h2 id="映射">映射</h2>
<p>映射类型在声明时的形式为 mapping(_KeyType =&gt; _ValueType)。<br>
使用：</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.0 &lt;0.9.0;

contract MappingExample {
    mapping(address =&gt; uint) public balances;

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}

contract MappingLBC {
    function f() public returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(this);
    }
}
</code></pre>
<h4 id="可迭代映射">可迭代映射</h4>
<p>映射本身是无法遍历的，即无法枚举所有的键。不过，可以在它们之上实现一个数据结构来进行迭代。</p>
<pre><code class="language-pragma">
struct IndexValue { uint keyIndex; uint value; } //keyindex 表示key的索引
struct KeyFlag { uint key; bool deleted; }  //key的实际值和删除状态

struct itmap {
    mapping(uint =&gt; IndexValue) data;
    KeyFlag[] keys; //创建一个key的数组来储存KEY的状态
    uint size;
}
</code></pre>
<h4 id="涉及-lvalues-的运算符">涉及 LValues 的运算符</h4>
<p>delete</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.0 &lt;0.9.0;

contract DeleteLBC {
    uint data;
    uint[] dataArray;

    function f() public {
        uint x = data;
        delete x; // 将 x 设为 0，并不影响数据
        delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本
        uint[] storage y = dataArray;
        delete dataArray;
        // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，
        // 因为它是一个存储位置是 storage 的对象的别名。
        // 另一方面：&quot;delete y&quot; 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。
        assert(y.length == 0);
    }
}
</code></pre>
<h4 id="基本类型之间的转换">基本类型之间的转换</h4>
<p>隐式转换<br>
uint8 可以转换成 uint16，int128 转换成 int256，但 int8 不能转换成 uint256<br>
显式转换<br>
如果某些情况下编译器不支持隐式转换，但是你很清楚你要做的结果，这种情况可以考虑显式转换。</p>
<pre><code class="language-uint32">uint16 b = uint16(a); // 此时 b 的值是 0x5678
</code></pre>
<h2 id="字面常量与基本类型的转换">字面常量与基本类型的转换</h2>
<h4 id="整型与字面常量转换">整型与字面常量转换</h4>
<p>十进制和十六进制字面常量可以隐式转换为任何足以表示它而不会截断的整数类型</p>
<pre><code class="language-uint8">uint32 b = 1234; // 可行
uint16 c = 0x123456; // 失败, 会截断为 0x3456
</code></pre>
<h4 id="定长字节数组与字面常量转换">定长字节数组与字面常量转换</h4>
<p>十进制字面常量不能隐式转换为定长字节数组。十六进制字面常量可以是，但仅当十六进制数字大小完全符合定长字节数组长度。 不过零值例外，零的十进制和十六进制字面常量都可以转换为任何定长字节数组类型:</p>
<pre><code class="language-bytes2">bytes2 b = 0x12; // 不可行
bytes2 c = 0x123; // 不可行
bytes2 d = 0x1234; // 可行
bytes2 e = 0x0012; // 可行
bytes4 f = 0; // 可行
bytes4 g = 0x0; // 可行
</code></pre>
<p>字符串字面常量和十六进制字符串字面常量可以隐式转换为定长字节数组，如果它们的字符数与字节类型的大小相匹配:</p>
<pre><code class="language-bytes2">bytes2 b = &quot;xy&quot;; // 可行
bytes2 c = hex&quot;12&quot;; // 不可行
bytes2 d = hex&quot;123&quot;; // n不可行
bytes2 e = &quot;x&quot;; // 不可行
bytes2 f = &quot;xyz&quot;; // 不可行
</code></pre>
<h4 id="地址类型">地址类型</h4>
<p>从 bytes20 或其他整型显示转换为 address 类型时，都会作为 address payable 类型。<br>
一个地址 address a 可以通过payable(a)　转换为　 address payable 类型.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[合约结构]]></title>
        <id>https://tangminjie.github.io/post/solidity/</id>
        <link href="https://tangminjie.github.io/post/solidity/">
        </link>
        <updated>2022-03-17T15:02:21.000Z</updated>
        <content type="html"><![CDATA[<p><strong>前言</strong><br>
solidity作为以太坊网络中的智能合约编程语言，这个篇章将以合约结构，类型，单位和全局变量，表达式和控制结构，以及合约demo来整理solidity相关的基础内容。</p>
<p><strong>状态变量</strong><br>
状态变量是永久地存储在合约存储中的。</p>
<pre><code class="language-pragma">
contract TinyStorage {
    uint storedXlbData; // 状态变量
    // ...
}
</code></pre>
<p><strong>函数</strong><br>
函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义</p>
<pre><code class="language-//">pragma solidity &gt;0.7.0 &lt;0.9.0;

contract TinyAuction {
    function Mybid() public payable { // 定义函数
        // ...
    }
}
// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
    return x * 2;
}
</code></pre>
<p><strong>函数修改器</strong><br>
函数修改器modifier可以用来以声明的方式修改函数语义。</p>
<pre><code class="language-pragma">
contract MyPurchase {
    address public seller;

    modifier onlySeller() { // 修改器
        require(
            msg.sender == seller,
            &quot;Only seller can call this.&quot;
        );
        _;
    }

    function abort() public onlySeller { // 修改器用法
        // ...
    }
}
</code></pre>
<p><strong>事件 Event</strong><br>
事件是能方便地调用以太坊虚拟机日志功能的接口。</p>
<pre><code class="language-pragma">contract TinyAuction {
    event HighestBidIncreased(address bidder, uint amount); // 事件

    function bid() public payable {
        // ...
        emit HighestBidIncreased(msg.sender, msg.value); // 触发事件
    }
}
</code></pre>
<p><strong>结构体</strong><br>
结构体是可以将几个变量分组的自定义类型。</p>
<pre><code class="language-pragma">
contract TinyBallot {
    struct Voter { // 结构体
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
}
</code></pre>
<p><strong>枚举类型</strong><br>
枚举可用来创建由一定数量的“常量值”构成的自定义类型</p>
<pre><code class="language-pragma">
contract Upchain {
    enum State { Created, Locked, InValid } // 枚举
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://tangminjie.github.io/post/hello-gridea/</id>
        <link href="https://tangminjie.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>