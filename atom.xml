<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tangminjie.github.io</id>
    <title>Tangminjie Blog</title>
    <updated>2022-04-25T04:49:04.871Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tangminjie.github.io"/>
    <link rel="self" href="https://tangminjie.github.io/atom.xml"/>
    <logo>https://tangminjie.github.io/images/avatar.png</logo>
    <icon>https://tangminjie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Tangminjie Blog</rights>
    <entry>
        <title type="html"><![CDATA[ERC-777]]></title>
        <id>https://tangminjie.github.io/post/erc-777/</id>
        <link href="https://tangminjie.github.io/post/erc-777/">
        </link>
        <updated>2022-04-23T09:18:08.000Z</updated>
        <content type="html"><![CDATA[<p>ERC-777 是一个易于交易的通证标准，可改进现有的 ERC-20 标准。<br>
对于ERC-20协议标准存在以下缺陷：<br>
1.对于payable 合约接受转账没办法再合约里记录是谁发过来多少币。<br>
2.由于ERC20 标准没有一个转账通知机制，很多ERC20代币误转到合约之后，再也没有办法把币转移出来，已经有大量的ERC20 因为这个原因被锁死。<br>
3.ERC20 转账时，无法携带额外的信息。<br>
当然对于使用ERC-20开发的defi业务。我们可以通过采用两个交易组合完成。方法是：第1步：先让用户把要转移的金额用 ERC20 的approve 授权的存币的合约（这步通常称为解锁），第2步：再次让用户调用存币合约的函数，合约中使用mapping来记录转入的代币数量和转入地址。通过 transferFrom 把代币从用户手里转移的合约内。<br>
ERC777很好的解决了这些问题，同时ERC777 也兼容 ERC20 标准。<br>
ERC777 在 ERC20的基础上定义了 send(dest, value, data) 来转移代币， send函数额外的参数用来携带其他的信息，send函数会检查持有者和接收者是否实现了相应的钩子函数，如果有实现（不管是普通用户地址还是合约地址都可以实现钩子函数），则调用相应的钩子函数。</p>
<h1 id="erc1820-接口注册表合约">ERC1820 接口注册表合约</h1>
<p>即便是一个普通用户地址，同样可以实现对 ERC777 转账的监听， 听起来有点神奇，其实这是通过 ERC1820 接口注册表合约来是实现的。RC1820标准定义了一个通用注册表合约，任何地址（合约或普通用户帐户）都可以注册它支持的接口以及哪个智能合约负责接口实现。并且任何人都可以查询此注册表，询问哪个地址是否实现了给定的接口以及哪个智能合约处理实现逻辑。<br>
ERC1820注册表合约可以部署在任何链上，并在所有链上的地址是相同的。有一个唯一在以太坊链上都相同的合约地址，它总是0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24。接口的后28个字节都为0的话，会认为是 ERC165 接口，并且注册表将转发到合约以查看是否实现了接口。此合约还充当 ERC165 缓存，以减少 gas 消耗。<br>
ERC1820合约提过了两个主要接口：</p>
<pre><code class="language-setInterfaceImplementer(address">用来设置地址（_addr）的接口（_interfaceHash 接口名称的 keccak256 ）由哪个合约实现（_implementer）。
getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address)
这个函数用来查询地址（_addr）的接口由哪个合约实现。
</code></pre>
<p>setInterfaceImplementer函数会参数信息记录到下面这个interfaces映射里：</p>
<pre><code class="language-//">mapping(address =&gt; mapping(bytes32 =&gt; address)) interfaces;
</code></pre>
<p>相对应的 getInterfaceImplementer() 通过 interfaces 这个mapping 来获得接口的实现。<br>
ERC777 使用 send转账时会分别在持有者和接收者地址上使用ERC1820 的getInterfaceImplementer函数进行查询，查看是否有对应的实现合约，ERC777 标准规范里预定了接口及函数名称，如果有实现则进行相应的调用。</p>
<h1 id="erc777-标准规范">ERC777 标准规范</h1>
<h2 id="erc777-接口">ERC777 接口</h2>
<p>ERC777 为了在实现上可以兼容ERC20，除了查询函数和ERC20一致外，操作接口均采用的独立的命名（避免相同的命令无法分辨是哪个标准），ERC777的接口定义如下，要求所有的ERC777代币合约都必须实现这些接口：</p>
<pre><code class="language-interface">    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function balanceOf(address holder) external view returns (uint256);

    // 定义代币最小的划分粒度
    function granularity() external view returns (uint256);

    // 操作员 相关的操作（操作员是可以代表持有者发送和销毁代币的账号地址）
    function defaultOperators() external view returns (address[] memory);
    function isOperatorFor(
        address operator,
        address holder
    ) external view returns (bool);
    function authorizeOperator(address operator) external;
    function revokeOperator(address operator) external;

    // 发送代币
    function send(address to, uint256 amount, bytes calldata data) external;
    function operatorSend(
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    // 销毁代币
    function burn(uint256 amount, bytes calldata data) external;
    function operatorBurn(
        address from,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    // 发送代币事件
    event Sent(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    // 铸币事件
    event Minted(
        address indexed operator,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    // 销毁代币事件
    event Burned(
        address indexed operator,
        address indexed from,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    // 授权操作员事件
    event AuthorizedOperator(
        address indexed operator,
        address indexed holder
    );

    // 撤销操作员事件
    event RevokedOperator(address indexed operator, address indexed holder);
}
</code></pre>
<h2 id="接口说明与实现约定">接口说明与实现约定</h2>
<p>ERC777 合约必须要通过 ERC1820 注册 ERC777Token 接口，这样任何人都可以查询合约是否是ERC777标准的合约，注册方法是: 调用ERC1820 注册合约的 setInterfaceImplementer 方法，参数 _addr 及 _implementer 均是合约的地址，_interfaceHash 是 ERC777Token 的 keccak256 哈希值（0xac7fbab5...177054）<br>
如果 ERC777 要实现ERC20标准，还必须通过ERC1820 注册ERC20Token接口。</p>
<h2 id="erc777-信息说明函数">ERC777 信息说明函数</h2>
<p>name()，symbol()，totalSupply()，balanceOf(address) 和含义和在ERC20 中完全一样。<br>
granularity() 用来定义代币最小的划分粒度（&gt;=1）， 要求必须在创建时设定，之后不可以更改，不管是在铸币、发送还是销毁操作的代币数量，必需是粒度的整数倍。</p>
<pre><code class="language-granularity"></code></pre>
<h2 id="操作员">操作员</h2>
<p>ERC777 定义了一个新的操作员角色，操作员被作为移动代币的地址。 每个地址直观地移动自己的代币，将持有人和操作员的概念分开可以提供更大的灵活性。此外，ERC777还可以定义默认操作员（默认操作员列表只能在代币创建时定义的，并且不能更改），默认操作员是被所有持有人授权的操作员，这可以为项目方管理代币带来方便，当然认何持有人仍然有权撤销默认操作员。<br>
<code>与ERC20中的 approve 、 transferFrom 不同，其未明确定义批准地址的角色。</code></p>
<h3 id="操作员相关的函数">操作员相关的函数</h3>
<p>1.defaultOperators(): 获取代币合约默认的操作员列表.<br>
2.authorizeOperator(address operator): 设置一个地址作为msg.sender 的操作员，需要触发AuthorizedOperator事件。<br>
3.revokeOperator(address operator): 移除 msg.sender 上 operator 操作员的权限， 需要触发RevokedOperator事件。<br>
4.isOperatorFor(address operator, address holder)： 是否是某个持有者的操作员。</p>
<h2 id="发送代币">发送代币</h2>
<p>ERC777 发送代币 使用以下两个方法：</p>
<pre><code class="language-send(address">
function operatorSend(
    address from,
    address to,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
</code></pre>
<p>operatorSend 可以通过参数operatorData携带操作者的信息，发送代币除了执行对应账户的余额加减和触发事件之外，还有额外的规定：<br>
1.如果持有者有通过 ERC1820 注册 ERC777TokensSender 实现接口， 代币合约必须调用其 tokensToSend 钩子函数。<br>
2.如果接收者有通过 ERC1820 注册 ERC777TokensRecipient 实现接口， 代币合约必须调用其 tokensReceived 钩子函数。<br>
3.如果有 tokensToSend 钩子函数，必须在修改余额状态之前调用。<br>
4.如果有 tokensReceived 钩子函数，必须在修改余额状态之后调用。<br>
5.调用钩子函数及触发事件时， data 和 operatorData必须原样传递，因为 tokensToSend 和 tokensReceived 函数可能根据这个数据取消转账（触发 revert）。<br>
6.其中data和operatorData都属于calldata类型。一般只有外部函数的参数（不包括返回参数）被强制指定为calldata。这种数据位置是只读的，不会持久化到区块链。</p>
<h2 id="erc777tokenssender-接口定义">ERC777TokensSender 接口定义</h2>
<p>如果持有者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 ERC777TokensSender 接口。有一个地方需要注意: 对于所有的 ERC777 合约， 一个持有者地址只能注册一个ERC777TokensSender接口实现。因此 ERC777TokensSender 实现会被多个ERC777合约调用，在ERC777TokensSender接口的实现合约里， msg.sender 是ERC777合约地址，而不是操作者。</p>
<pre><code class="language-interface">    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}
</code></pre>
<h2 id="erc777tokensrecipient-接口定义">ERC777TokensRecipient 接口定义</h2>
<p>如果接收者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 ERC777TokensRecipient 接口。<br>
如果接收者是一个合约地址， 则必须要注册及实现 ERC777TokensRecipient 接口（这样可以防止代币被锁死），如果没有实现，ERC777代币合约必须revert 回退交易状态。</p>
<pre><code class="language-interface">    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;
}
</code></pre>
<h1 id="铸币与销毁">铸币与销毁</h1>
<p>铸币（挖矿）是产生新币的过程，销毁代币则相反，在ERC20 中，没有明确定义这两个行为，通常会transfer方法和Transfer事件来表达。<br>
ERC777 则定义了代币从铸币、转移到销毁的整个生命周期。<br>
ERC777 没有定义铸币的方法名，只定义了 Minted事件，因为很多代币，是在创建的时候就确定好代币的数量。<br>
如果有需要合约可以自己定义铸币函数，铸币函数在实现时要求：<br>
1.必须触发Burned事件。<br>
2.总供应量必须减少代币销毁量， 持有者的余额必须减少代币销毁的数量。<br>
3.如果持有者通过ERC1820注册ERC777TokensSender 实现，必须调用持有者的tokensToSend钩子函数。</p>
<h1 id="erc777-代币实现">ERC777 代币实现</h1>
<p>OpenZeppelin 实现了一个 ERC777 基础合约，要实现自己的ERC777代币只需要继承 OpenZeppelin ERC777。<br>
实现主要是两步：通过基类ERC777的构造函数确认代币名称、代号以及默认操作员（可为空），然后调用 _mint 初始化发行量，注意发行量的小数位是固定的18位（和ether保持一致），在合约内部是按小数位保存的，因此发行的币数需要乘上10^18。</p>
<pre><code class="language-import">
contract MyERC777 is ERC777 {
    constructor(
        address[] memory defaultOperators
    )
        ERC777(&quot;MyERC777&quot;, &quot;LBC7&quot;, defaultOperators)
        public
    {
        uint initialSupply = 2100 * 10 ** 18;
        _mint(msg.sender, msg.sender, initialSupply, &quot;&quot;, &quot;&quot;);
    }
}
</code></pre>
<h1 id="监听代币收款">监听代币收款</h1>
<p>如果我们要为一个合约监听它的代币接受。我们可以在合约种继承IERC777Recipient来实现钩子函数：<br>
其中要注意：<br>
1.实例IERC1820Registry合约地址是一个唯一地址，全网统一。<br>
2.TOKENS_RECIPIENT_INTERFACE_HASH是ERC777TokensRecipient的哈希值，是一个固定值。<br>
3.setInterfaceImplementer设置回调的时候第一个地址为监听地址。第二个为监听合约实现地址。<br>
在回调种我们可以对转账进行记录或者处理账本或者黑白名单等操作。</p>
<pre><code class="language-import">import &quot;@openzeppelin/contracts/token/ERC777/IERC777.sol&quot;;
import &quot;@openzeppelin/contracts/introspection/IERC1820Registry.sol&quot;;

contract Merit is IERC777Recipient {

  mapping(address =&gt; uint) public givers;
  address _owner;
  IERC777 _token;

  IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);

  // keccak256(&quot;ERC777TokensRecipient&quot;)
  bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =
      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;

  constructor(IERC777 token) public {
    _erc1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));
    _owner = msg.sender;
    _token = token;
  }

// 收款时被回调
  function tokensReceived(
      address operator,
      address from,
      address to,
      uint amount,
      bytes calldata userData,
      bytes calldata operatorData
  ) external {
    givers[from] += amount;
  }
  }
</code></pre>
<h1 id="普通账户地址监听代币转出">普通账户地址监听代币转出</h1>
<p>当然我们除了为合约地址监听代币转入转出以外，也可以为账户地址来监听代币转出。监听代币的转出可以让持有者对发出去的代币有更多的控制，例如持有者可以设置一些黑名单，禁止操作员对黑名单内账号转账。<br>
根据 ERC1820 标准，只有账号的管理者才可以为账号注册接口实现合约，<br>
如果一个合约要为某个地址（或自身）实现某个接口， 则需要实现下面这个接口:</p>
<pre><code class="language-interface">    /// @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。
    /// @param interfaceHash 接口名称的 keccak256 哈希值
    /// @param addr 为哪一个地址实现接口
    /// @return 只有当合约为地址'addr'实现'interfaceHash'时返回 ERC1820_ACCEPT_MAGIC
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}
</code></pre>
<p>通过在 canImplementInterfaceForAddress 返回 ERC1820_ACCEPT_MAGIC 以声明实现了 interfaceHash 对应的接口。在调用ERC1820的 setInterfaceImplementer 函数设置接口实现时，会通过 canImplementInterfaceForAddress 检查合约时候实现了接口。</p>
<pre><code class="language-import">import &quot;@openzeppelin/contracts/token/ERC777/IERC777.sol&quot;;
import &quot;@openzeppelin/contracts/introspection/IERC1820Registry.sol&quot;;
import &quot;@openzeppelin/contracts/introspection/IERC1820Implementer.sol&quot;;


contract SenderControl is IERC777Sender, IERC1820Implementer {

  IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
  bytes32 constant private ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(&quot;ERC1820_ACCEPT_MAGIC&quot;));

  //    keccak256(&quot;ERC777TokensSender&quot;)
  bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =
        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;

  mapping(address =&gt; bool) blacklist;
  address _owner;

  constructor() public {
    _owner = msg.sender;
  }

function setInterfaceImp(address userAddress) public {
_erc1820.setInterfaceImplementer(userAddress, TOKENS_RECIPIENT_INTERFACE_HASH, address(this));
}

  //  account call erc1820.setInterfaceImplementer
  function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32) {
    if (interfaceHash == TOKENS_SENDER_INTERFACE_HASH) {
      return ERC1820_ACCEPT_MAGIC;
    } else {
      return bytes32(0x00);
    }
  }

  function setBlack(address account, bool b) external {
    require(msg.sender == _owner, &quot;no premission&quot;);
    blacklist[account] = b;
  }

  function tokensToSend(
      address operator,
      address from,
      address to,
      uint amount,
      bytes calldata userData,
      bytes calldata operatorData
  ) external {
    if (blacklist[to]) {
      revert(&quot;ohh... on blacklist&quot;);
    }
  }

}
</code></pre>
<p>给发送者账号(假设为A）设置代理合约的方法为：先部署代理合约，获得代理合约地址， 然后用A账号去调用 ERC1820 的 setInterfaceImplementer函数，参数分别是 A的地址、接口的 keccak256 即0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895 以及 代理合约地址。</p>
<h1 id="openzeppelin-erc-777-源码分析">openzeppelin ERC-777 源码分析</h1>
<p>在openzeppelin/constracts中erc-777主要有一下4个文件：<br>
1.ERC777.sol: 协议具体的逻辑实现。<br>
2.IERC777.sol: 对外提供的接口。<br>
3.IERC777Recipient.sol：监听接受代币回调接口。<br>
4.IERC777Sender.sol: 监听发送代币回调接口。<br>
我们主要review一下 ERC777.sol：<br>
首先ERC777继承了 IERC777 和 IERC20接口：<br>
<code>contract ERC777 is Context, IERC777, IERC20 {</code><br>
所以erc777 合约逻辑是完全兼容ERC20协议的。在ERC-20的基础上增加了以下属性：</p>
<pre><code class="language-bytes32">    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(&quot;ERC777TokensRecipient&quot;);

    //操作员数组
    address[] private _defaultOperatorsArray;

    // 操作员权限映射
    mapping(address =&gt; bool) private _defaultOperators;

    //每个操作员地址对应的每个合约地址权限的映射，以及撤销的映射。
    mapping(address =&gt; mapping(address =&gt; bool)) private _operators;
    mapping(address =&gt; mapping(address =&gt; bool)) private _revokedDefaultOperators;
</code></pre>
<p>在构造函数中遍历默认操作员数组，并且将操作员权限初始化。然后向ERC1820合约注册&quot;ERC777&quot;和&quot;ERC20&quot;接口：</p>
<pre><code class="language-constructor(">        string memory name_,
        string memory symbol_,
        address[] memory defaultOperators_
    ) {
        _name = name_;
        _symbol = symbol_;

        _defaultOperatorsArray = defaultOperators_;
        for (uint256 i = 0; i &lt; defaultOperators_.length; i++) {
            _defaultOperators[defaultOperators_[i]] = true;
        }

        // register interfaces
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(&quot;ERC777Token&quot;), address(this));
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(&quot;ERC20Token&quot;), address(this));
    }
</code></pre>
<p>ERC-777保留了ERC-20的tranform函数，并且增加了_send 发送方法：</p>
<pre><code class="language-function">        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData,
        bool requireReceptionAck
    ) internal virtual {
        require(from != address(0), &quot;ERC777: send from the zero address&quot;);
        require(to != address(0), &quot;ERC777: send to the zero address&quot;);

        address operator = _msgSender();

        _callTokensToSend(operator, from, to, amount, userData, operatorData);

        _move(operator, from, to, amount, userData, operatorData);

        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);
    }
    ```
    在调用发送_move发送代币之前，调用了_callTokensToSend 用来回调注册的监听发送代币的回调函数。在发送代币之后调用了监听接受代币的回调函数。
    _callTokensToSend和_callTokensReceived的实现类似：
```    function _callTokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    ) private {
        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);
        if (implementer != address(0)) {
            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);
        }
    }
</code></pre>
<p>首先通过_ERC1820_REGISTRY.getInterfaceImplementer向对应的地址获取是否注册了监听。并且调用相应地址的回调函数：<br>
IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ERC-721]]></title>
        <id>https://tangminjie.github.io/post/erc-721/</id>
        <link href="https://tangminjie.github.io/post/erc-721/">
        </link>
        <updated>2022-04-21T08:43:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>什么是非同质化代币？<br>
非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！</p>
<h1 id="erc-721-是什么">ERC-721 是什么?</h1>
<p>和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs。<br>
那怎么理解非同质代币呢?ERC20代币是可置换的，且可细分为N份（1 = 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。所以每一个erc721的token都是独一无二的。</p>
<h1 id="erc721标准">ERC721标准</h1>
<p>ERC721作为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p>
<pre><code class="language-pragma">
interface ERC721 /* is ERC165 */ {
    
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    //返回由_owner持有的NFTs的数量
    function balanceOf(address _owner) external view returns (uint256);
    //返回tokenid代币持有者的地址
    function ownerOf(uint256 _tokenId) external view returns (address);

    //转移NFT所有权，一次成功的转移操作必须发起 Transer 事件
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
    //transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;

    //授予地址_approved具有_tokenId的控制权，方法成功后需触发Approval 事件
    function approve(address _approved, uint256 _tokenId) external payable;
    //授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。
    function setApprovalForAll(address _operator, bool _approved) external;
    //用来查询某个tokenid的授权。
    function getApproved(uint256 _tokenId) external view returns (address);
    //查询_owner 对 _operator是否所有授权
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}
</code></pre>
<p>其中我们需要特别注意 safeTransferFrom(): 的用法：<br>
safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：<br>
1.调用者msg.sender应该是当前tokenId的所有者或被授权的地址<br>
2._from 必须是 _tokenId的所有者<br>
3._tokenId 应该是当前合约正在监测的NFTs 中的任何一个<br>
4._to 地址不应该为 0<br>
5.如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为<code>bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))抛出异常。</code><br>
一个可接收NFT的合约必须实现ERC721TokenReceiver接口：</p>
<pre><code class="language-interface">        /// @return `bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))`
        function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);
    }
</code></pre>
<p>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</p>
<h1 id="erc165-标准">ERC165 标准</h1>
<p>ERC721标准同时要求必须符合ERC165标准 ，其接口如下：</p>
<pre><code class="language-interface">    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
</code></pre>
<p>ERC165同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。<br>
interfaceID为函数选择器，计算方式有两种，如：bytes4(keccak256('supportsInterface(bytes4)'));或ERC165.supportsInterface.selector，多个函数的接口ID为函数选择器的异或值。</p>
<h1 id="可选实现接口erc721metadata">可选实现接口：ERC721Metadata</h1>
<p>ERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。<br>
其接口定义如下：</p>
<pre><code class="language-interface">    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function tokenURI(uint256 _tokenId) external view returns (string);
}
</code></pre>
<p>接口说明：<br>
1.name(): 返回合约名字，尽管是可选，但强烈建议实现，即便是返回空字符串。<br>
2.symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。<br>
3.tokenURI(): 返回_tokenId所对应的外部资源文件的URI（通常是IPFS或HTTP(S)路径）。外部资源文件需要包含名字、描述、图片，其格式的要求如下：</p>
<pre><code class="language-{">    &quot;title&quot;: &quot;Asset Metadata&quot;,
permalink: token-erc721
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
        &quot;name&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Identifies the asset to which this NFT represents&quot;,
        },
        &quot;description&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Describes the asset to which this NFT represents&quot;,
        },
        &quot;image&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.&quot;,
        }
    }
}
</code></pre>
<p>tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。</p>
<h1 id="可选实现接口erc721enumerable">可选实现接口：ERC721Enumerable</h1>
<p>ERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下：</p>
<pre><code class="language-interface">    function totalSupply() external view returns (uint256);
    function tokenByIndex(uint256 _index) external view returns (uint256);
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
}
</code></pre>
<p>接口说明：<br>
1.totalSupply(): 返回NFT总量<br>
2.tokenByIndex(): 通过索引返回对应的tokenId。<br>
3.tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。</p>
<h1 id="补充说明">补充说明</h1>
<h2 id="ntf-ids">NTF IDs</h2>
<p>NTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有：<br>
1.从0开始，每新加一个NFT，NTF ID加1<br>
2.使用sha3后uuid 转换为 NTF ID</p>
<h2 id="与erc-20的兼容性">与ERC-20的兼容性</h2>
<p>ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。</p>
<h2 id="交易-挖矿-销毁">交易、挖矿、销毁</h2>
<p>在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。</p>
<h1 id="openzeppelin-中-erc-721的实现">openzeppelin 中 ERC-721的实现</h1>
<p>在@openzeppelin/constracts/erc721.sol中实现了erc721的标准。<br>
ERC721合约继承了 Context, 抽象合约，ERC165, IERC721, IERC721Metadata接口合约。<br>
<code>contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {</code><br>
1.Context 抽象合约提供了有关当前执行上下文的信息，包括事务的发送者及其数据。可以调用获得msg.sender 地址。<br>
2.ERC165 提供了supportsInterface 接口。可以通过type(IERC721).interfaceId来查询合约实现了哪些接口。<br>
3.IERC721，erc721的标准接口。<br>
4.IERC721Metadata提供了合约的元数据接口，包括nfttoken的name，symbol，tokenUrl。<br>
并且相对于ERC20 _mint接口需要提供 tokenid 并且增加了_setTokenURI接口将tokenID和tokenUrl绑定。tokenUrl通常为IPFS地址或者HTTPS地址。</p>
<h2 id="构建-erc721-代币合约">构建 ERC721 代币合约</h2>
<pre><code class="language-//">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;
import &quot;@openzeppelin/contracts/utils/Counters.sol&quot;;

contract GameItem is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() public ERC721(&quot;GameItem&quot;, &quot;ITM&quot;) {}

    function awardItem(address player, string memory tokenURI)
        public
        returns (uint256)
    {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }
}
</code></pre>
<p>ERC721合同包括所有标准扩展（和IERC721Metadata）IERC721Enumerable。这就是该_setTokenURI方法的来源：我们使用它来存储项目的元数据。<br>
另请注意，与 ERC20 不同，ERC721 缺少decimals字段，因为每个令牌都是不同的并且不能被分区。</p>
<pre><code class="language-可以创建新项目：">
&gt; gameItem.awardItem(playerAddress, &quot;https://game.example/item-id-8u5h2m.json&quot;)
Transaction successful. Transaction hash: 0x...
Events emitted:
 - Transfer(0x0000000000000000000000000000000000000000, playerAddress, 7)
以及查询到的每个项目的所有者和元数据：

&gt; gameItem.ownerOf(7)
playerAddress
&gt; gameItem.tokenURI(7)
&quot;https://game.example/item-id-8u5h2m.json&quot;
这tokenURI应该解析为可能类似于以下内容的 JSON 文档：

{
    &quot;name&quot;: &quot;Thor's hammer&quot;,
    &quot;description&quot;: &quot;Mjölnir, the legendary hammer of the Norse god of thunder.&quot;,
    &quot;image&quot;: &quot;https://game.example/item-id-8u5h2m.png&quot;,
    &quot;strength&quot;: 20
}
</code></pre>
<p>您会注意到该项目的信息包含在元数据中，但该信息不在链上！所以游戏开发者可以改变底层元数据，改变游戏规则！如果你想把所有的物品信息放在链上，你可以扩展 ERC721 来这样做（虽然它会相当昂贵）。您还可以利用 IPFS 来存储 tokenURI 信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ERC-20]]></title>
        <id>https://tangminjie.github.io/post/erc-20/</id>
        <link href="https://tangminjie.github.io/post/erc-20/">
        </link>
        <updated>2022-04-20T07:03:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="概述">概述</h1>
<p>ERC-20 提供了一个同质化代币的标准，换句话说，每个代币与另一个代币（在类型和价值上）完全相同。 例如，一个 ERC-20 代币就像 ETH 一样，意味着一个代币会并永远会与其他代币一样。<br>
ERC20简单理解成以太坊上的一个代币协议，所有基于以太坊开发的代币合约都遵守这个协议。遵守这些协议的代币我们可以认为是标准化的代币，而标准化带来的好处是兼容性好。这些标准化的代币可以被各种以太坊钱包支持，用于不同的平台和项目。</p>
<h1 id="erc20协议标准">ERC20协议标准</h1>
<p>ERC20标准规定，一共包括：6个函数，2个event，3个变量。</p>
<pre><code class="language-contract">    //查询代币发行总量
  	function totalSupply() public constant returns (uint);  
      //查询某个账户余额
  	function balanceOf(address tokenOwner) public constant returns (uint balance);
      //查询某个账户可转账金额。用于控制代币的交易
   	function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
       //从当前账户，实现代币交易
 	function transfer(address to, uint tokens) public returns (bool success); 
     //授权，允许某个账户花费此地址可用的代币数
  	function approve(address spender, uint tokens) public returns (bool success); 
      //实现用户之间的代币交易
  	function transferFrom(address from, address to, uint tokens) public returns (bool success);
     //当代币交易时会触发此函数
  	event Transfer(address indexed from, address indexed to, uint tokens);  
     //当成功调用approve函数后会触发此函数
  	event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    string public constant name = &quot;Zarten Token&quot;; //代币名称
    string public constant symbol = &quot;ZAR&quot;;              //代币简称
    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places
    // 0.0000000000000000001  个代币
    //返回token使用的小数点后几位。比如设置为3,就是支持0.001表示。一般为18位
}
</code></pre>
<h1 id="erc20工作原理">ERC20工作原理</h1>
<h2 id="变量及函数实现">变量及函数实现</h2>
<h3 id="定义变量">定义变量</h3>
<p>一般定义两个映射变量：保存每个地址对应的余额。<br>
<code>mapping (address =&gt; uint256) public balances</code><br>
两层映射。保存着某个地址A允许另一个地址B可操作的金额。最外层映射为某个地址A，内层映射为另一个地址B，值为可操作（发起交易）金额总量。<br>
<code>mapping(address =&gt; mapping(address =&gt;uint256)) public allowed</code></p>
<h2 id="函数实现">函数实现</h2>
<h3 id="balanceof">balanceOf()</h3>
<p>从映射变量balances中取出某个地址的余额。</p>
<pre><code class="language-function">       return balances[tokenOwner];
}
</code></pre>
<h3 id="transfer">transfer()</h3>
<p>当前账户转账操作。<br>
msg.sender为保留字，指这个函数的地址。<br>
sub：减 add：加<br>
首先从当前账户减去相应金额。<br>
同时往对方账户加上对应金额。<br>
并调用Transfer函数做通知。</p>
<pre><code class="language-function">    balances[msg.sender] = balances[msg.sender].sub(tokens);
    balances[to] = balances[to].add(tokens);
    Transfer(msg.sender, to, tokens);
    return true;
}
</code></pre>
<h3 id="transferfrom">transferFrom()</h3>
<p>用户之间账户转账操作。由from地址发起转账交易。<br>
from地址账户减去相应金额。<br>
from从msg.sender总共可操作金额减少相应金额。<br>
to地址账户增加相应金额。<br>
调用Transfer函数做通知。<br>
approve后可以转移对方代币给自己</p>
<pre><code class="language-function">        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(from, to, tokens);
        return true;
 }
</code></pre>
<h3 id="approve">approve()</h3>
<p>设置某账户spender可操控msg.sender的代币数。<br>
设置spender地址从msg.sender可使用的代币数。<br>
调用Approval函数做通知。</p>
<pre><code class="language-function">        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
 }
</code></pre>
<h1 id="erc20高级功能代码">ERC20高级功能代码</h1>
<p>ERC20代币有时需要其他一些额外的高级功能，比如代币管理、代币增发、空投代币、代币冻结、销毁代币、代币兑换等。</p>
<h2 id="代币管理">代币管理</h2>
<p>有时代币需要有一个管理者功能。使用onlyOwner修饰的接口只能有合约所有者调用，否则会抛出异常。<br>
添加一个owned合约，如下：</p>
<pre><code class="language-contract">    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</code></pre>
<h2 id="代币增发">代币增发</h2>
<p>代币增发可使代币总供应量增加，可以指定某个账户的代币增加，同时总供应量也随之增加。<br>
使用onlyOwner修饰器，只能owner调用。this表示当前合约。</p>
<pre><code class="language-function">        balances[target] += mintedAmount;
        _totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
</code></pre>
<h2 id="代币销毁">代币销毁</h2>
<p>首先添加一个通知客户端代币消费的事件。</p>
<pre><code class="language-event"></code></pre>
<p>销毁代币非为销毁管理者代币和销毁用户代币。此时需要管理者去进行销毁。</p>
<h2 id="销毁管理者代币">销毁管理者代币</h2>
<pre><code class="language-function">        require(balances[owner] &gt;= _value);
        balances[owner] -= _value;
        _totalSupply -= _value;
        emit Burn(owner, _value);
        return true;
    }
</code></pre>
<h2 id="销毁用户代币">销毁用户代币</h2>
<p>销毁之前需要判断用户代币的数量是否大于销毁数量，并且判断allowed可以使用的代币大于需要销毁的代币数量。</p>
<pre><code class="language-function">        require(balances[_from] &gt;= _value);
        require(_value &lt;= allowed[_from][owner]);
        balances[_from] -= _value;
        allowed[_from][owner] -= _value;
        _totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
</code></pre>
<h2 id="代币冻结">代币冻结</h2>
<p>有时需要冻结账户代币，也就是此账户不能转账操作。<br>
1.首先添加一个账户冻结代币的映射<br>
<code>mapping (address =&gt; bool) public frozenAccount;</code><br>
2.添加冻结的通知函数<br>
<code>event FrozenFunds(address target, bool frozen);</code><br>
3..添加冻结的函数</p>
<pre><code class="language-function">        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
</code></pre>
<p>4.在转账函数中判断涉及账户是否为冻结账户，否则不允许转账操作</p>
<pre><code class="language-require(!frozenAccount[from]);">require(!frozenAccount[to]);
</code></pre>
<h2 id="批量代币空投">批量代币空投</h2>
<p>有时需要往很多地址空投一些代币，这样可以使用批量转账。<br>
假设从管理员账户空投。关键字memory为声明内存型的，存储的内容会在函数被调用（包括外部函数）时擦除，所以其使用开销相对较小。</p>
<pre><code class="language-//空投代币">    function AirDrop(address[] memory _recipients, uint _values) onlyOwner public returns (bool) {
        require(_recipients.length &gt; 0);

        for(uint j = 0; j &lt; _recipients.length; j++){
            transfer(_recipients[j], _values);
        }

        return true;
    }
</code></pre>
<p>当然在实际应用中空投的数量并不是绝对的，大部分业务根据持有的代币比例或者NFT来计算空投。</p>
<h2 id="代币兑换">代币兑换</h2>
<p>有时代币需要与其他货币（Ether）进行兑换。<br>
msg.value表示随消息发送的wei的数量，payable修饰函数表示允许从调用中接收以太币。<br>
1.设置买卖价格的变量</p>
<pre><code class="language-uint256">uint256 public buyPrice;
</code></pre>
<p>2.设置价格函数</p>
<pre><code class="language-function">        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
</code></pre>
<p>3.接收以太币进行买操作</p>
<pre><code class="language-function">        uint amount = msg.value / buyPrice;
        emit Transfer(address(this), owner, amount);
    }
</code></pre>
<p>4.卖操作</p>
<pre><code class="language-function">        require(address(this).balance &gt;= amount * sellPrice);
        emit Transfer(owner, address(this), amount);
        owner.transfer(amount * sellPrice);
    }
</code></pre>
<p>当然在实际应用中的价格由dex或者uniswap等去中心化交易所，通过AMM协议的交易对计算得出。</p>
<h1 id="openzeppelin-erc-20实现">openzeppelin ERC-20实现</h1>
<p>我们在写合约业务的时候可以选择自己实现ERC20的协议，当然也可以使用openzeppelin的第三方库。openzeppelin中有完善的ERC20实现。<br>
首先我们来看下一下openzeppelin官方文档中对于ERC20的描述：<br>
ERC20 代币合约跟踪可替代代币：任何一种代币都完全等同于任何其他代币；没有任何代币具有与之相关的特殊权利或行为。这使得 ERC20 代币可用于交换货币、投票权、质押等媒介。<br>
使用openzeppelin来构建erc20-token也十分的方便：<br>
我们在hardhat工程中通过 npm install @openzeppelin/contracts 来安装openzeppelin的支持，就可以import进来使用：<br>
我们的合约经常通过继承使用，在这里我们将重用ERC20基本标准实现以及name,symbol和decimals可选扩展。此外，我们正在创建一个initialSupply令牌，它将分配给部署合约的地址。</p>
<pre><code class="language-pragma">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;
contract GLDToken is ERC20 {
    constructor(uint256 initialSupply) public ERC20(&quot;Gold&quot;, &quot;GLD&quot;) {
        _mint(msg.sender, initialSupply);
    }
}
</code></pre>
<p>就是这样！部署后，我们将能够查询部署者的余额：</p>
<pre><code>&gt; GLDToken.balanceOf(deployerAddress)
1000000000000000000000
我们也可以将这些代币转移到其他账户：

&gt; GLDToken.transfer(otherAddress, 300000000000000000000)
&gt; GLDToken.balanceOf(otherAddress)
300000000000000000000
&gt; GLDToken.balanceOf(deployerAddress)
700000000000000000000
</code></pre>
<h2 id="关于decimals">关于decimals</h2>
<p>通常，您希望能够将您的代币分成任意数量：例如，如果您拥有5 GLD，您可能想发送1.5 GLD给朋友，并留给3.5 GLD自己。不幸的是，Solidity 和 EVM 不支持这种行为：只能使用整数（整数）。为了解决这个问题，ERC20提供了一个decimals字段，用于指定令牌有多少个小数位。为了能够转移1.5 GLD，decimals必须至少1，因为该数字有一个小数位。就像ETH的最小单位是wei。1eth = 10^18wei。<br>
在openzeppelin中默认情况下，ERC20使用值18for decimals。要使用不同的值，您需要在构造函数中调用_setupDecimals。<br>
因此，如果您想5使用 18 位小数的代币合约发送代币，调用的方法实际上是：<br>
<code>transfer(recipient, 5 * 10^18);</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[合约]]></title>
        <id>https://tangminjie.github.io/post/he-yue/</id>
        <link href="https://tangminjie.github.io/post/he-yue/">
        </link>
        <updated>2022-04-18T13:36:33.000Z</updated>
        <content type="html"><![CDATA[<p>Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</p>
<h2 id="创建合约">创建合约</h2>
<p>可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。<br>
一些集成开发环境，例如 Remix, 通过使用一些UI用户界面使创建合约的过程更加顺畅。 在以太坊上通过编程创建合约使用 JavaScript API web3.js。<br>
创建合约时， 合约的 构造函数 (一个用关键字 constructor 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。<br>
如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。</p>
<pre><code class="language-pragma">
contract OwnedToken {
    // TokenCreator 是如下定义的合约类型.
    // 不创建新合约的话，也可以引用它。
    TokenCreator creator;
    address owner;
    bytes32 name;

    // 这是注册 creator 和设置名称的构造函数。
    constructor(bytes32 _name) {
        // 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。
        // 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们，
        // 因为合约本身还不存在。
        owner = msg.sender;
        // 从 `address` 到 `TokenCreator` ，是做显式的类型转换
        // 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。
        creator = TokenCreator(msg.sender);
        name = _name;
    }

    function changeName(bytes32 newName) public {
        // 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的，
        // 所以这里的比较是可行的。
        if (msg.sender == address(creator))
            name = newName;
    }

    function transfer(address newOwner) public {
        // 只有当前所有者才能发送 token。
        if (msg.sender != owner) return;
        // 我们也想询问 creator 是否可以发送。
        // 请注意，这里调用了一个下面定义的合约中的函数。
        // 如果调用失败（比如，由于 gas 不足），会立即停止执行。
        if (creator.isTokenTransferOK(owner, newOwner))
            owner = newOwner;
    }
}

contract TokenCreator {
    function createToken(bytes32 name)
       public
       returns (OwnedToken tokenAddress)
    {
        // 创建一个新的 Token 合约并且返回它的地址。
        // 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为
        // 这是在 ABI 中可用的最接近的类型。
        return new OwnedToken(name);
    }

    function changeName(OwnedToken tokenAddress, bytes32 name)  public {
        // 同样，`tokenAddress` 的外部类型也是 `address` 。
        tokenAddress.changeName(name);
    }

    function isTokenTransferOK(address currentOwner, address newOwner)
        public
        view
        returns (bool ok)
    {
        // 检查一些任意的情况。
        address tokenAddress = msg.sender;
        return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);
    }
}
</code></pre>
<h2 id="可见性和getter函数">可见性和getter函数</h2>
<p>函数和状态变量有四种可见性类型。 函数可以指定为 external ，public ，internal 或者 private。 对于状态变量，不能设置为 external ，默认是 internal 。<br>
external<br>
外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.<br>
public<br>
public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。<br>
internal<br>
这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。<br>
private<br>
private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</p>
<h2 id="getter函数">Getter函数</h2>
<p>编译器自动为所有 public 状态变量创建 getter 函数。</p>
<pre><code class="language-pragma">
contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public {
        uint local = c.data();
    }
}
</code></pre>
<p>getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果使用外部访问（即用 this. ），它被认作为一个函数。</p>
<pre><code class="language-pragma">
contract C {
    uint public data;
    function x() public {
        data = 3; // 内部访问
        uint val = this.data(); // 外部访问
    }
}
</code></pre>
<p>如果你有一个数组类型的 public 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。这个机制以避免返回整个数组时的高成本gas。 可以使用如 data(0) 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如:</p>
<pre><code class="language-pragma">
contract arrayExample {
  // public state variable
  uint[] public myArray;

  // 指定生成的Getter 函数
  /*
  function myArray(uint i) public view returns (uint) {
      return myArray[i];
  }
  */

  // 返回整个数组
  function getArray() public view returns (uint[] memory) {
      return myArray;
  }
}
现在可以使用 getArray() 获得整个数组，而 myArray(i) 是返回单个元素。
</code></pre>
<h2 id="函数修改器">函数修改器</h2>
<p>使用 修改器modifier 可以轻松改变函数的行为。 例如，它们可以在执行函数之前自动检查某个条件。 修改器modifier 是合约的可继承属性，并可能被派生合约覆盖 , 但前提是它们被标记为 virtual。</p>
<pre><code class="language-//">pragma solidity &gt;0.7.0 &lt;0.9.0;

contract owned {
    constructor() { owner = payable(msg.sender); }

    address owner;

    // 这个合约只定义一个修改器，但并未使用： 它将会在派生合约中用到。
    // 修改器所修饰的函数体会被插入到特殊符号 _; 的位置。
    // 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。
    modifier onlyOwner {
        require(
            msg.sender == owner,
            &quot;Only owner can call this function.&quot;
        );
        _;
    }
    contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(
            !locked,
            &quot;Reentrant call.&quot;
        );
        locked = true;
        _;
        locked = false;
    }

    // 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。
    // `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。
    function f() public noReentrancy returns (uint) {
        (bool success,) = msg.sender.call(&quot;&quot;);
        require(success);
        return 7;
    }
}
</code></pre>
<p>如果你想访问定义在合约 C 的 修改器modifier m ， 可以使用 C.m 去引用它，而不需要使用虚拟表查找。<br>
只能使用在当前合约或在基类合约中定义的 修改器modifier , 修改器modifier 也可以定义在库里面，但是他们被限定在库函数使用。<br>
如果同一个函数有多个 修改器modifier，它们之间以空格隔开，修改器modifier 会依次检查执行。</p>
<h2 id="constant-和-immutable-状态变量">Constant 和 Immutable 状态变量</h2>
<p>状态变量声明为 constant (常量)或者 immutable （不可变量），在这两种情况下，合约一旦部署之后，变量将不在修改。对于 constant 常量, 他的值在编译器确定，而对于 immutable, 它的值在部署时确定。<br>
与常规状态变量相比，常量和不可变量的gas成本要低得多。 对于常量，赋值给它的表达式将复制到所有访问该常量的位置，并且每次都会对其进行重新求值。 这样可以进行本地优化。<br>
不可变变量在构造时进行一次求值，并将其值复制到代码中访问它们的所有位置。 对于这些值，将保留32个字节，即使它们适合较少的字节也是如此。 因此，常量有时可能比不可变量更便宜。</p>
<h4 id="constant">Constant</h4>
<p>如果状态变量声明为 constant (常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。 任何通过访问 storage，区块链数据（例如 block.timestamp, address(this).balance 或者 block.number）或执行数据（ msg.value 或 gasleft() ） 或对外部合约的调用来给它们赋值都是不允许的。</p>
<h4 id="immutable">Immutable</h4>
<p>声明为不可变量(immutable)的变量的限制要比声明为常量(constant) 的变量的限制少：可以在合约的构造函数中或声明时为不可变的变量分配任意值。 不可变量在构造期间无法读取其值，并且只能赋值一次。</p>
<h2 id="函数">函数</h2>
<p>可以在合约内部和外部定义函数。<br>
合约之外的函数（也称为“自由函数”）始终具有隐式的 internal 可见性。 它们的代码包含在所有调用它们合约中，类似于内部库函数。</p>
<pre><code class="language-//">pragma solidity &gt;0.7.0 &lt;0.9.0;
function sum(uint[] memory _arr) pure returns (uint s) {
    for (uint i = 0; i &lt; _arr.length; i++)
        s += _arr[i];
}
contract ArrayExample {
    bool found;
    function f(uint[] memory _arr) public {
        // This calls the free function internally.
        // The compiler will add its code to the contract.
        uint s = sum(_arr);
        require(s &gt;= 10);
        found = true;
    }
}
</code></pre>
<h4 id="函数参数及返回值">函数参数及返回值</h4>
<p>与 Javascript 一样，函数可能需要参数作为输入; 而与 Javascript 和 C 不同的是，它们可能返回任意数量的参数作为输出。</p>
<h4 id="函数参数输入参数">函数参数（输入参数)</h4>
<p>函数参数的声明方式与变量相同。不过未使用的参数可以省略参数名。</p>
<pre><code class="language-pragma">
contract Simple {
    uint sum;
    function taker(uint _a, uint _b) public {
        sum = _a + _b;
    }
}
</code></pre>
<h2 id="返回变量">返回变量</h2>
<p>函数返回变量的声明方式在关键词 returns 之后，与参数的声明方式相同。</p>
<pre><code class="language-pragma">
contract Simple {
    function arithmetic(uint _a, uint _b)
        public
        pure
        returns (uint o_sum, uint o_product)
    {
        o_sum = _a + _b;
        o_product = _a * _b;
    }
}
</code></pre>
<h4 id="返回多个值">返回多个值</h4>
<p>当函数需要使用多个值，可以用语句 return (v0, v1, ..., vn) 。 参数的数量需要和声明时候一致。</p>
<h4 id="view-视图函数">View 视图函数</h4>
<p>可以将函数声明为 view 类型，这种情况下要保证不修改状态。view常被用来作为只读函数，不消耗GAS。</p>
<h4 id="pure-纯函数">Pure 纯函数</h4>
<p>函数可以声明为 pure ，在这种情况下，承诺不读取也不修改状态。pure常被用来作为常数计算。不消耗GAS。</p>
<h2 id="receive-接收以太函数">receive 接收以太函数</h2>
<p>个合约最多有一个 receive 函数, 声明函数为： <code>receive() external payable { ... }</code><br>
不需要 function 关键字，也没有参数和返回值并且必须是　external　可见性和　payable 修饰． 它可以是 virtual 的，可以被重载也可以有 修改器modifier 。在对合约没有任何附加数据调用（通常是对合约转账）是会执行 receive 函数．　例如　通过 .send() or .transfer() 如果 receive 函数不存在，　但是有payable　的 fallback 回退函数 那么在进行纯以太转账时，fallback 函数会调用．<br>
如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．<br>
更糟的是，receive 函数可能只有 2300 gas 可以使用（如，当使用 send 或 transfer 时）， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :<br>
1.写入存储<br>
2.创建合约<br>
3.调用消耗大量 gas 的外部函数<br>
4.发送以太币</p>
<h2 id="fallback">fallback</h2>
<p>合约可以最多有一个回退函数。函数声明为： <code>fallback () external [payable]</code>没有function　关键字。　必须是　external　可见性，它可以是 virtual 的，可以被重载也可以有 修改器modifier 。<br>
如果在一个对合约调用中，没有其他函数与给定的函数标识符匹配fallback会被调用． 或者在没有 receive 函数　时，而没有提供附加数据对合约调用，那么fallback 函数会被执行。<br>
fallback　函数始终会接收数据，但为了同时接收以太时，必须标记为payable 。</p>
<pre><code class="language-pragma">contract Test {
    // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。
    // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符
    fallback() external { x = 1; }
    uint x;
}

// 这个合约会保留所有发送给它的以太币，没有办法返还。
contract TestPayable {
    // 除了纯转账外，所有的调用都会调用这个函数．
    // (因为除了 receive 函数外，没有其他的函数).
    // 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).
    fallback() external payable { x = 1; y = msg.value; }

    // 纯转账调用这个函数，例如对每个空empty calldata的调用
    receive() external payable { x = 2; y = msg.value; }
    uint x;
    uint y;
}

contract Caller {
    function callTest(Test test) public returns (bool) {
        (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));
        require(success);
        //  test.x 结果变成 == 1。

        // address(test) 不允许直接调用 ``send`` ,  因为 ``test`` 没有 payable 回退函数
        //  转化为 ``address payable`` 类型 , 然后才可以调用 ``send``
        address payable testPayable = payable(address(test));


        // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。
        // test.send(2 ether）;
    }

    function callTestPayable(TestPayable test) public returns (bool) {
        (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));
        require(success);
        // 结果 test.x 为 1  test.y 为 0.
        (success,) = address(test).call{value: 1}(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));
        require(success);
        // 结果test.x 为1 而 test.y 为 1.

        // 发送以太币, TestPayable 的 receive　函数被调用．
        require(payable(test).send(2 ether));
        // 结果 test.x 为 2 而 test.y 为 2 ether.

        return true;
    }

}
</code></pre>
<h2 id="函数重载">函数重载</h2>
<p>合约可以具有多个不同参数的同名函数，称为“重载”（overloading），这也适用于继承函数。以下示例展示了合约 A 中的重载函数 f。</p>
<pre><code class="language-pragma">
contract A {
    function f(uint _in) public pure returns (uint out) {
        out = _in;
    }

    function f(uint _in, bool _really) public pure returns (uint out) {
        if (_really)
            out = _in;
    }
}
</code></pre>
<p>重载函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。以下两个 f 函数重载都接受了 ABI 的地址类型，虽然它们在 Solidity 中被认为是不同的。</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.16 &lt;0.9.0;

contract A {
    function f(B _in) public pure returns (B out) {
        out = _in;
    }

    function f(address _in) public pure returns (address out) {
        out = _in;
    }
}

contract B {
}
</code></pre>
<h4 id="重载解析和参数匹配">重载解析和参数匹配</h4>
<p>通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重载函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重载候选项。如果一个候选都没有，解析失败。</p>
<pre><code class="language-pragma">
contract A {
    function f(uint8 _in) public pure returns (uint8 out) {
        out = _in;
    }

    function f(uint256 _in) public pure returns (uint256 out) {
        out = _in;
    }
}
</code></pre>
<h2 id="事件-events">事件 Events</h2>
<p>声明事件，再 emit 事件，类似与 nodejs，与 web3 交互类似与 websocket</p>
<pre><code class="language-pragma">
contract ClientReceipt {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) public payable {
        // 事件使用 emit 触发事件。
        // 我们可以过滤对 `Deposit` 的调用，从而用 Javascript API 来查明对这个函数的任何调用（甚至是深度嵌套调用）。
        emit Deposit(msg.sender, _id, msg.value);
    }
}
</code></pre>
<p>使用 JavaScript API 调用事件的用法如下：</p>
<pre><code class="language-var">var ClientReceipt = web3.eth.contract(abi);
var clientReceipt = ClientReceipt.at(&quot;0x1234...xlb67&quot; /* 地址 */);

var event = clientReceipt.Deposit();

// 监听变化
event.watch(function(error, result) {
    // 结果包含 非索引参数 以及 主题 topic
    if (!error)
        console.log(result);
});

// 或者通过传入回调函数，立即开始听监
var event = clientReceipt.Deposit(function(error, result) {
    if (!error)
        console.log(result);
});
</code></pre>
<h2 id="继承">继承</h2>
<p>Solidity 支持多重继承包括多态。<br>
Solidity 的继承系统与Python的继承系统非常相似，特别是多重继承方面,另外一样可以使用super.f();来调用父类方法。<br>
下面的例子进行了详细的说明。</p>
<pre><code class="language-//">   pragma solidity &gt;=0.7.0 &lt;0.9.0;

   contract Owned {
       constructor() public { owner = payable(msg.sender); }
       address payable owner;
   }

   // 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部（internal）函数和状态变量，
   // 但无法通过 this 来外部访问。
   contract Destructible is Owned {

    // 关键字`virtual`表示该函数可以在派生类中“overriding”。

       function destroy() virtual public {
           if (msg.sender == owner) selfdestruct(owner);
       }
   }

   // 这些抽象合约仅用于给编译器提供接口。
   // 注意函数没有函数体。
   // 如果一个合约没有实现所有函数，则只能用作接口。
   abstract contract Config {
       function lookup(uint id) public virtual returns (address adr);
   }

   abstract contract NameReg {
       function register(bytes32 name) public virtual;
       function unregister() public virtual;
    }

   // 可以多重继承。请注意，owned 也是 Destructible 的基类，
   // 但只有一个 owned 实例（就像 C++ 中的虚拟继承）。
   contract Named is Owned, Destructible {
       constructor(bytes32 name) {
           Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
           NameReg(config.lookup(1)).register(name);
       }

       // 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。
       // 如果重载函数有不同类型的输出参数，会导致错误。
       // 本地和基于消息的函数调用都会考虑这些重载。

//如果要覆盖函数，则需要使用 `override` 关键字。 如果您想再次覆盖此函数，则需要再次指定`virtual`关键字。

       function destroy() public virtual override {
           if (msg.sender == owner) {
               Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
               NameReg(config.lookup(1)).unregister();
               // 仍然可以调用特定的重载函数。
               Destructible.destroy();
           }
       }
   }

   // 如果构造函数接受参数，
   // 则需要在声明（合约的构造函数）时提供，
   // 或在派生合约的构造函数位置以修改器调用风格提供（见下文）。
   contract PriceFeed is Owned, Destructible, Named(&quot;GoldFeed&quot;) {
       function updateInfo(uint newInfo) public {
           if (msg.sender == owner) info = newInfo;
       }

       // Here, we only specify `override` and not `virtual`.
       // This means that contracts deriving from `PriceFeed`
       // cannot change the behaviour of `destroy` anymore.
       function destroy() public override(Destructible, Named) { Named.destroy(); }

       function get() public view returns(uint r) { return info; }

       uint info;
   }
</code></pre>
<h3 id="函数重写overriding">函数重写(Overriding)</h3>
<p>父合约标记为 virtual 函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 override 修饰。<br>
重写函数只能将覆盖函数的可见性从 external 更改为 public 。<br>
可变性可以按照以下顺序更改为更严格的一种： nonpayable 可以被 view 和 pure 覆盖。 view 可以被 pure 覆盖。 payable 是一个例外，不能更改为任何其他可变性。</p>
<pre><code class="language-//">pragma solidity &gt;=0.7.0 &lt;0.9.0;

contract Base
{
    function foo() virtual external view {}
}

contract Middle is Base {}

contract Inherited is Middle
{
    function foo() override public pure {}
}
</code></pre>
<p>对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。</p>
<pre><code class="language-pragma">
contract Base1
{
    function foo() virtual public {}
}

contract Base2
{
    function foo() virtual public {}
}

contract Inherited is Base1, Base2
{
    // 继承自两个基类合约定义的foo(), 必须显示的指定 override
    function foo() public override(Base1, Base2) {}
}
</code></pre>
<p>不过如果（重写的）函数继承自一个公共的父合约， override 是可以不用显示指定的。如果函数没有标记为 virtual ， 那么派生合约将不能更改函数的行为（即不能重写）。<br>
注意：private 的函数是不可以标记为 virtual 的。除接口之外（因为接口会自动作为 virtual ），没有实现的函数必须标记为 virtual。</p>
<p>如果getter 函数的参数和返回值都和外部函数一致时，外部（external）函数是可以被 public 的状态变量被重写的，例如：</p>
<pre><code class="language-pragma">
contract A
{
    function f() external view virtual returns(uint) { return 5; }
}

contract B is A
{
    uint public override f;
}
</code></pre>
<p>注意：尽管public 的状态变量可以重写外部函数，但是public 的状态变量不能被重写。</p>
<h3 id="修改器重写">修改器重写</h3>
<p>修改器重写也可以被重写，工作方式和 :ref:<code>函数重写 &lt;function-overriding&gt;</code>_ 类似。 需要被重写的修改器也需要使用 virtual 修饰，override 则同样修饰重载，例如：</p>
<pre><code class="language-pragma">
contract Base
{
    modifier foo() virtual {_;}
}

contract Inherited is Base
{
    modifier foo() override {_;}
}
</code></pre>
<p>如果是多重继承，所有直接父合约必须显示指定override， 例如：</p>
<pre><code class="language-pragma">
contract Base1
{
    modifier foo() virtual {_;}
}

contract Base2
{
    modifier foo() virtual {_;}
}

contract Inherited is Base1, Base2
{
    modifier foo() override(Base1, Base2) {_;}
}
</code></pre>
<h3 id="构造函数">构造函数</h3>
<p>构造函数是使用 constructor 关键字声明的一个可选函数, 它在创建合约时执行, 可以在其中运行合约初始化代码。<br>
如果没有构造函数, 合约将假定采用默认构造函数, 它等效于 constructor() {}</p>
<pre><code class="language-//">pragma solidity &gt;0.6.99 &lt;0.8.0;

abstract contract A {
    uint public a;

    constructor(uint _a) {
        a = _a;
    }
}

contract B is A(1) {
    constructor() {}
}
</code></pre>
<h3 id="基类构造函数的参数">基类构造函数的参数</h3>
<p>所有基类合约的构造函数将在下面解释的线性化规则被调用。如果基构造函数有参数, 派生合约需要指定所有参数。这可以通过两种方式来实现。<br>
一种方法直接在继承列表中调用基类构造函数（is Base(7)）。 另一种方法是像 修改器modifier 使用方法一样， 作为派生合约构造函数定义头的一部分，（Base(_y * _y))。 如果构造函数参数是常量并且定义或描述了合约的行为，使用第一种方法比较方便。 如果基类构造函数的参数依赖于派生合约，那么必须使用第二种方法。</p>
<pre><code class="language-//">pragma solidity &gt;0.6.99 &lt;0.8.0;

contract Base {
    uint x;
    constructor(uint _x) { x = _x; }
}

// 直接在继承列表中指定参数
contract Derived1 is Base(7) {
    constructor() {}
}

// 或通过派生的构造函数中用 修饰符 &quot;modifier&quot;
contract Derived2 is Base {
    constructor(uint _y) Base(_y * _y) {}
}
</code></pre>
<h3 id="多重继承与线性化">多重继承与线性化</h3>
<p>简单来说继承层次结构中有多个构造函数时，继承线性化特别重要。 构造函数将始终以线性化顺序执行，无论在继承合约的构造函数中提供其参数的顺序如何。</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.0 &lt;0.8.0;

contract X {}
contract A is X {}
// 编译出错
contract C is A, X {}
</code></pre>
<pre><code class="language-//">pragma solidity &gt;0.6.99 &lt;0.8.0;

contract Base1 {
    constructor() {}
}

contract Base2 {
    constructor() {}
}

//  构造函数以以下顺序执行:
//  1 - Base1
//  2 - Base2
//  3 - Derived1
contract Derived1 is Base1, Base2 {
    constructor() Base1() Base2() {}
}

// 构造函数以以下顺序执行:
//  1 - Base2
//  2 - Base1
//  3 - Derived2
contract Derived2 is Base2, Base1 {
    constructor() Base2() Base1() {}
}

// 构造函数仍然以以下顺序执行:
//  1 - Base2
//  2 - Base1
//  3 - Derived3
contract Derived3 is Base2, Base1 {
    constructor() Base1() Base2() {}
}
</code></pre>
<h3 id="继承有相同名字的不同类型成员">继承有相同名字的不同类型成员</h3>
<p>当继承时合约出现了一下相同名字会被认为是一个错误：<br>
1.函数和 修改器modifier 同名<br>
2.函数和事件同名<br>
3.事件和 修改器modifier 同名<br>
有一种例外情况，状态变量的 getter 函数可以覆盖 external 函数。</p>
<h2 id="抽象合约">抽象合约</h2>
<p>如果未实现合约中的至少一个函数，则需要将合约标记为 abstract。 即使实现了所有功能，合同也可能被标记为abstract。这样的抽象合约不能直接实例化。 如果抽象合约本身确实都有实现所有定义的函数，也是正确的。 下例显示了抽象合约作为基类的用法:</p>
<pre><code class="language-pragma">
abstract contract Feline {
  function utterance() public pure returns (bytes32);
}

contract Cat is Feline {
  function utterance() public pure returns (bytes32) { return &quot;miaow&quot;; }
}
</code></pre>
<p>如果合约继承自抽象合约，并且没有通过重写来实现所有未实现的函数， 它依然需要标记为抽象 abstract 合约。<br>
注意：抽象合约不能用一个无实现的函数重写一个实现了的虚函数。</p>
<h2 id="接口">接口</h2>
<p>接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制<br>
1.法继承其他合约,不过可以继承其他接口。<br>
2.所有的函数都需要是 external<br>
3.无法定义构造函数。<br>
4.无法定义状态变量。<br>
接口基本上基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。</p>
<pre><code class="language-pragma">
interface Token {
    enum TokenType { Fungible, NonFungible }
    struct Coin { string obverse; string reverse; }
    function transfer(address recipient, uint amount) external;
}
</code></pre>
<p>接口可以继承其他的接口，遵循同样继承规则。</p>
<pre><code class="language-pragma">
interface ParentA {
    function test() external returns (uint256);
}

interface ParentB {
    function test() external returns (uint256);
}

interface SubInterface is ParentA, ParentB {
    // 必须重新定义 test 函数，以表示兼容父合约含义
    function test() external override(ParentA, ParentB) returns (uint256);
}
</code></pre>
<h2 id="库">库</h2>
<p>库与合约类似，它们只需要在特定的地址部署一次，并且它们的代码可以通过 EVM 的 DELEGATECALL (Homestead 之前使用 CALLCODE 关键字)特性进行重用。<br>
下面的示例说明如何使用库：</p>
<pre><code class="language-pragma">
  // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。
  struct Data {
    mapping(uint =&gt; bool) flags;
  }

library Set {

  // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。
  // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。
  function insert(Data storage self, uint value)
      public
      returns (bool)
  {
      if (self.flags[value])
          return false; // 已经存在
      self.flags[value] = true;
      return true;
  }

  function remove(Data storage self, uint value)
      public
      returns (bool)
  {
      if (!self.flags[value])
          return false; // 不存在
      self.flags[value] = false;
      return true;
  }

  function contains(Data storage self, uint value)
      public
      view
      returns (bool)
  {
      return self.flags[value];
  }
}

contract C {
    Data knownValues;

    function register(uint value) public {
        // 不需要库的特定实例就可以调用库函数，
        // 因为当前合约就是“instance”。
        require(Set.insert(knownValues, value));
    }
    // 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。
}
</code></pre>
<p>以下示例展示了如何在库中使用内存类型和内部函数来实现自定义类型，而无需支付外部函数调用的开销：</p>
<pre><code class="language-pragma">
struct bigint {
    uint[] limbs;
}

library BigInt {

    function fromUint(uint x) internal pure returns (bigint r) {
        r.limbs = new uint[](1);
        r.limbs[0] = x;
    }

    function add(bigint _a, bigint _b) internal pure returns (bigint r) {
        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));
        uint carry = 0;
        for (uint i = 0; i &lt; r.limbs.length; ++i) {
            uint a = limb(_a, i);
            uint b = limb(_b, i);
            r.limbs[i] = a + b + carry;
            if (a + b &lt; a || (a + b == type(uint).max &amp;&amp; carry &gt; 0))
                carry = 1;
            else
                carry = 0;
        }
        if (carry &gt; 0) {
            // 太差了，我们需要增加一个 limb
            uint[] memory newLimbs = new uint[](r.limbs.length + 1);
            for (i = 0; i &lt; r.limbs.length; ++i)
                newLimbs[i] = r.limbs[i];
            newLimbs[i] = carry;
            r.limbs = newLimbs;
        }
    }

    function limb(bigint _a, uint _limb) internal pure returns (uint) {
        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;
    }

    function max(uint a, uint b) private pure returns (uint) {
        return a &gt; b ? a : b;
    }
}

contract C {
    using BigInt for bigint;

    function f() public pure {
        bigint memory x = BigInt.fromUint(7);
        bigint memory y = BigInt.fromUint(type(uint).max);
        bigint memory z = x.add(y);
        assert(z.limb(1) &gt; 0);
    }
}
</code></pre>
<p>与合约相比，库的限制：<br>
1.没有状态变量<br>
2.不能够继承或被继承<br>
3.不能接收以太币<br>
4.不可以被销毁</p>
<h3 id="库的函数签名与选择器">库的函数签名与选择器</h3>
<p>与合约 ABI 相似，选择器由签名的Keccak256哈希的前四个字节组成。可以使用 .selector 成员从Solidity中获取其值，如下所示：</p>
<pre><code class="language-pragma">
library L {
    function f(uint256) external {}
}

contract C {
    function g() public pure returns (bytes4) {
        return L.f.selector;
    }
}
</code></pre>
<h3 id="库的调用保护">库的调用保护</h3>
<p>如果库的代码是通过 CALL 来执行，而不是 DELEGATECALL 或者 CALLCODE 那么执行的结果会被回退， 除非是对 view 或者 pure 函数的调用。</p>
<h2 id="using-for">Using For</h2>
<p>在当前的合约上下里, 指令 using A for B; 可用于附加库函数（从库 A）到任何类型（B）。 这些函数将接收到调用它们的对象作为它们的第一个参数（像 Python 的 self 变量）。<br>
using A for *; 的效果是，库 A 中的函数被附加在任意的类型上。</p>
<pre><code class="language-pragma">
// 这是和之前一样的代码，只是没有注释。
struct Data { mapping(uint =&gt; bool) flags; }

library Set {

  function insert(Data storage self, uint value)
      public
      returns (bool)
  {
      if (self.flags[value])
        return false; // 已经存在
      self.flags[value] = true;
      return true;
  }

  function remove(Data storage self, uint value)
      public
      returns (bool)
  {
      if (!self.flags[value])
          return false; // 不存在
      self.flags[value] = false;
      return true;
  }

  function contains(Data storage self, uint value)
      public
      view
      returns (bool)
  {
      return self.flags[value];
  }
}

contract C {
    using Set for Data; // 这里是关键的修改
    Data knownValues;

    function register(uint value) public {
        // Here, all variables of type Data have
        // corresponding member functions.
        // The following function call is identical to
        // `Set.insert(knownValues, value)`
        // 这里， Data 类型的所有变量都有与之相对应的成员函数。
        // 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。
        require(knownValues.insert(value));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[表达式和控制结构]]></title>
        <id>https://tangminjie.github.io/post/biao-da-shi-he-kong-zhi-jie-gou/</id>
        <link href="https://tangminjie.github.io/post/biao-da-shi-he-kong-zhi-jie-gou/">
        </link>
        <updated>2022-04-18T09:47:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="控制结构">控制结构</h2>
<p>JavaScript 中的大部分控制结构在 Solidity 中都是可用的，除了 switch 和 goto。 因此 Solidity 中有 if，else，while，do，for，break，continue，return，? : 这些与在 C 或者 JavaScript 中表达相同语义的关键词。<br>
Solidity还支持 try/catch 语句形式的异常处理， 但仅用于 外部函数调用　和　合约创建调用．<br>
注意：与 C 和 JavaScript 不同， Solidity 中非布尔类型数值不能转换为布尔类型，因此 if (1) { ... } 的写法在 Solidity 中 无效 。</p>
<h2 id="函数调用">函数调用</h2>
<p>当前合约中的函数可以直接（“从内部”）调用，这些函数调用在 EVM 中被解释为简单的跳转。</p>
<h2 id="外部函数调用">外部函数调用</h2>
<p>表达式 this.g(8); 和 c.g(2); （其中 c 是合约实例）也是有效的函数调用，但是这种情况下，函数将会通过一个消息调用来进行“外部调用”，而不是直接的跳转。 请注意，不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。<br>
当调用其他合约的函数时，随函数调用发送的 Wei 和 gas 的数量可以分别由特定选项　{value: 10, gas: 10000}<br>
请注意，不建议明确指定gas，因为操作码的gas 消耗将来可能会发生变化。 任何发送给合约 Wei 将被添加到该合约的总余额中：</p>
<pre><code class="language-pragma">
contract InfoFeed {
    function info() public payable returns (uint ret) { return 42; }
}

contract Consumer {
    InfoFeed feed;
    function setFeed(InfoFeed addr) public { feed = addr; }
    function callFeed() public { feed.info{value: 10, gas: 800}(); }
}
//payable 修饰符要用于修饰 info 函数，否则，value 选项将不可用。
</code></pre>
<h2 id="具名调用和匿名函数参数">具名调用和匿名函数参数</h2>
<p>函数调用参数也可以按照任意顺序由名称给出，如果它们被包含在 { } 中， 如以下示例中所示。参数列表必须按名称与函数声明中的参数列表相符，但可以按任意顺序排列。</p>
<pre><code class="language-pragma">
contract C {
    mapping(uint =&gt; uint) data;

    function f() public {
        set({value: 2, key: 3});
    }

    function set(uint key, uint value) public {
        data[key] = value;
    }

}
</code></pre>
<h2 id="省略函数参数名称">省略函数参数名称</h2>
<p>未使用参数的名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问</p>
<pre><code class="language-pragma">
contract C {
    // 省略参数名称
    function func(uint k, uint) public pure returns(uint) {
        return k;
    }
}
</code></pre>
<h2 id="通过-new-创建合约">通过 new 创建合约</h2>
<p>使用关键字 new 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。</p>
<pre><code class="language-pragma">
contract D {
    uint x;
    function D(uint a) payable {
        x = a;
    }
}

contract C {
    D d = new D(4); // 将作为合约 C 构造函数的一部分执行

    function createD(uint arg) public {
        D newD = new D(arg);
    }

    function createAndEndowD(uint arg, uint amount) public payable {
                //随合约的创建发送 ether
        D newD = (new D){value:amount}(arg);  
    }
}
//通过使用 value 选项创建 D 的实例时可以附带发送 Ether，但是不能限制 gas 的数量。 如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。
</code></pre>
<h2 id="加盐的合约创建-create2">加“盐”的合约创建 create2</h2>
<p>在创建合约时，将根据创建合约的地址和每次创建合约交易时的计数器(nonce)来计算合约的地址。<br>
如果你指定了一个可选的 <code>salt</code>（一个bytes32值），那么合约创建将使用另一种机制来生成新合约的地址：<br>
它将根据给定的盐值，创建合约的字节码和构造函数参数来计算创建合约的地址。地址计算公式如下：</p>
<pre><code class="language-keccak256">address— 调用CREATE2的智能合约的地址
salt— 随机数,其实是确定的比如用userId计算出的哈希
init_code— 要部署合约的字节码
</code></pre>
<p>特别注意，不使用计数器（“nonce”）。 这样可以在创建合约时提供更大的灵活性：你可以在创建新合约之前就推导出（将要创建的）合约地址。甚至是，还可以依赖此地址（即便它还不存在）来创建其他合约。一个主要用例场景是充当链下交互仲裁合约，仅在有争议时才需要创建。</p>
<pre><code class="language-//">pragma solidity ^0.7.0;

contract D {
   uint public x;
   constructor(uint a) {
       x = a;
   }
}

contract C {
   function createDSalted(bytes32 salt, uint arg) public {
       /// 这个复杂的表达式只是告诉我们，如何预先计算地址。
       /// 这里仅仅用来说明。
       /// 实际上，你仅仅需要 ``new D{salt: salt}(arg)``.
       address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(
           bytes1(0xff),
           address(this),
           salt,
           keccak256(abi.encodePacked(
               type(D).creationCode,
               arg
           ))
       )))));

       D d = new D{salt: salt}(arg);
       require(address(d) == predictedAddress);
   }
}
</code></pre>
<h2 id="表达式计算顺序">表达式计算顺序</h2>
<h2 id="赋值">赋值</h2>
<h4 id="解构赋值和返回多值">解构赋值和返回多值</h4>
<pre><code class="language-ragma">
contract C {
    uint index;

    function f() public pure returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        //基于返回的元组来声明变量并赋值
        (uint x, bool b, uint y) = f();
        //交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。
        (x, y) = (y, x);
        //元组的末尾元素可以省略（这也适用于变量声明）。
        (index,,) = f(); // 设置 index 为 7
    }
}
</code></pre>
<h4 id="数组和结构体的复杂性">数组和结构体的复杂性</h4>
<p>在下面的示例中, 对 g(x) 的调用对 x 没有影响, 因为它在内存中创建了存储值独立副本。但是, h(x) 成功修改 x , 因为只传递引用而不传递副本。</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.22 &lt;0.9.0;

 contract C {
    uint[20] x;

     function f() public {
        g(x);
        h(x);
    }

     function g(uint[20] memory y) internal pure {
        y[2] = 3;
    }

     function h(uint[20] storage y) internal {
        y[3] = 4;
    }
}
</code></pre>
<h2 id="作用域和声明">作用域和声明</h2>
<p>Solidity 中的作用域规则遵循了 C99（与其他很多语言一样）：变量将会从它们被声明之后可见，直到一对 { } 块的结束。作为一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 for 循环的结束。</p>
<h2 id="算术运算的检查模式与非检查模式">算术运算的检查模式与非检查模式</h2>
<p>当对无限制整数执行算术运算，其结果超出结果类型的范围，这是就发生了上溢出或下溢出。<br>
在Solidity 0.8.0之前，算术运算总是会在发生溢出的情况下进行“截断”，从而得靠引入额外检查库来解决这个问题（如 OpenZepplin 的 SafeMath）。<br>
而从Solidity 0.8.0开始，所有的算术运算默认就会进行溢出检查，额外引入库将不再必要。<br>
如果想要之前“截断”的效果，可以使用 unchecked 代码块：</p>
<pre><code class="language-//">pragma solidity &gt;0.7.99;
contract C {
    function f(uint a, uint b) pure public returns (uint) {
        // 溢出会返回“截断”的结果
        unchecked { return a - b; }
    }
    function g(uint a, uint b) pure public returns (uint) {
        // 溢出会抛出异常
        return a - b;
    }
}
</code></pre>
<h2 id="错误处理及异常assert-require-revert">错误处理及异常：Assert, Require, Revert</h2>
<p>同样作为判断一个条件是否满足的函数，require会退回剩下的gas，而assert会烧掉所有的gas。require 常用来执行条件判断，作为函数执行的一个合理的判断。assert常用来中断函数，抛出异常。一般来说正常运行的函数不会运行到assert。<br>
revert会撤回所有的状态转变。但是它有两点不同：</p>
<ol>
<li>它允许你返回一个值；</li>
<li>它会把所有剩下的gas退回给caller</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单位和全局变量]]></title>
        <id>https://tangminjie.github.io/post/dan-wei-he-quan-ju-bian-liang/</id>
        <link href="https://tangminjie.github.io/post/dan-wei-he-quan-ju-bian-liang/">
        </link>
        <updated>2022-04-18T09:00:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="以太币ether-单位">以太币Ether 单位</h2>
<pre><code class="language-assert(1">assert(1 gwei == 1e9);
assert(1 ether == 1e18);
</code></pre>
<h2 id="时间单位">时间单位</h2>
<p>秒是缺省时间单位，在时间单位之间，数字后面带有 seconds、 minutes、 hours、 days 和 weeks 的可以进行换算，基本换算关系如下：</p>
<pre><code class="language-1">1 minutes == 60 seconds
1 hours == 60 minutes
1 days == 24 hours
1 weeks == 7 days
</code></pre>
<p>注意：years 已经在 0.5.0 版本去除了，因为闰年的原因。</p>
<pre><code class="language-function">    if (block.timestamp &gt;= start + daysAfter * 1 days) {
        // ...
    }
}
</code></pre>
<h2 id="特殊变量和函数">特殊变量和函数</h2>
<p>在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。<br>
<strong>区块和交易属性</strong></p>
<pre><code class="language-blockhash(uint">block.chainid (uint): 当前链 id
block.coinbase ( address ): 挖出当前区块的矿工地址
block.difficulty ( uint ): 当前区块难度
block.gaslimit ( uint ): 当前区块 gas 限额
block.number ( uint ): 当前区块号
block.timestamp ( uint): 自 unix epoch 起始当前区块以秒计的时间戳
gasleft() returns (uint256) ：剩余的 gas
msg.data ( bytes ): 完整的 calldata
msg.sender ( address ): 消息发送者（当前调用）
msg.sig ( bytes4 ): calldata 的前 4 字节（也就是函数标识符）
msg.value ( uint ): 随消息发送的 wei 的数量
tx.gasprice (uint): 交易的 gas 价格
tx.origin (address payable): 交易发起者（完全的调用链）
</code></pre>
<h2 id="abi-编码及解码函数">ABI 编码及解码函数</h2>
<pre><code class="language-abi.decode(bytes">abi.encode(...) returns (bytes)： ABI - 对给定参数进行编码
abi.encodePacked(...) returns (bytes)：对给定参数执行 紧打包编码 ，注意，可以不明确打包编码。
abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)： ABI - 对给定第二个开始的参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回
abi.encodeWithSignature(string signature, ...) returns (bytes)：等价于 abi.encodeWithSelector(bytes4(keccak256(signature), ...)
</code></pre>
<h2 id="错误处理">错误处理</h2>
<p>assert(bool condition) 如果不满足条件，则会导致 Panic 错误，则撤销状态更改 - 用于检查内部错误。<br>
require(bool condition) 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。<br>
require(bool condition, string memory message) 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。<br>
revert() 终止运行并撤销状态更改。<br>
revert(string memory reason) 终止运行并撤销状态更改，可以同时提供一个解释性的字符串。<br>
注意：assert 不返回gas费用，require返回gas费用。revert()会回滚所有状态，并且返回剩余gas</p>
<h2 id="数学和密码学函数">数学和密码学函数</h2>
<p>1.addmod(uint x, uint y, uint k) returns (uint)<br>
计算 (x + y) % k，加法会在任意精度下执行，并且加法的结果即使超过 2<strong>256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。<br>
2.mulmod(uint x, uint y, uint k) returns (uint)<br>
计算 (x * y) % k，乘法会在任意精度下执行，并且乘法的结果即使超过 2</strong>256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。<br>
3.keccak256((bytes memory) returns (bytes32)<br>
计算 Keccak-256 哈希。<br>
4.sha256(bytes memory) returns (bytes32)<br>
计算参数的 SHA-256 哈希。<br>
5.ripemd160(bytes memory) returns (bytes20)<br>
计算参数的 RIPEMD-160 哈希。<br>
6.ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)<br>
利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。ecrecover 返回一个 address, 而不是 address payable 。他们之前的转换参考 address payable ，如果需要转移资金到恢复的地址。</p>
<h2 id="地址成员">地址成员</h2>
<pre><code class="language-&lt;address&gt;.balance">以 Wei 为单位的 地址类型 Address 的余额。
&lt;address&gt;.code (bytes memory)
在 地址类型 Address 上的代码(可以为空)
&lt;address&gt;.codehash (bytes32)
:ref:`address`的codehash
&lt;address payable&gt;.transfer(uint256 amount)
向 地址类型 Address 发送数量为 amount 的 Wei，失败时抛出异常，使用固定（不可调节）的 2300 gas 的矿工费。
&lt;address payable&gt;.send(uint256 amount) returns (bool)
向 地址类型 Address 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。
&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)
用给定的有效载荷（payload）发出低级 CALL 调用，返回成功状态及返回数据，发送所有可用 gas，也可以调节 gas。
&lt;address&gt;.delegatecall(bytes memory) returns (bool, bytes memory)
用给定的有效载荷 发出低级 DELEGATECALL 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。 发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。
&lt;address&gt;.staticcall(bytes memory) returns (bool, bytes memory)
用给定的有效载荷 发出低级 STATICCALL 调用 ，返回成功状态并返回数据，发送所有可用 gas，也可以调节 gas。
</code></pre>
<h2 id="合约相关">合约相关</h2>
<p>1.this (当前的合约类型) 当前合约，可以显示转换为 地址类型 Address。<br>
2.selfdestruct(address payable recipient) 销毁合约，并把余额发送到指定 地址类型 Address</p>
<h2 id="类型信息">类型信息</h2>
<p>表达式 type(X) 可用于检索参数 X 的类型信息。 目前，此功能还比较有限( X 仅能是合约和整型)，但是未来应该会扩展。</p>
<p>用于合约类型 C 支持以下属性:</p>
<pre><code class="language-type(C).name">type(C).creationCode        //获得包含创建合约字节码的内存字节数组
type(C).runtimeCode         //获得合约运行时字节码的内存字节数组
type(I).interfaceId             //返回接口``I`` 的 bytes4 类型的接口 ID
type(T).min                        //返回整型T的最小值
type(T).max                        //返回整型T的最大值
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类型]]></title>
        <id>https://tangminjie.github.io/post/solidity-leixing/</id>
        <link href="https://tangminjie.github.io/post/solidity-leixing/">
        </link>
        <updated>2022-04-17T15:49:30.000Z</updated>
        <content type="html"><![CDATA[<p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。<br>
Solidity 提供了几种基本类型，并且基本类型可以用来组合出复杂类型。<br>
<strong>需要注意以下几点:</strong><br>
1.“undefined”或“null”值的概念在Solidity中不存在。<br>
2.变量声明后将有默认初始值，其初始值字节表示全部为零。<br>
3.bool 类型的默认值是 false。<br>
4.uint 或 int 类型的默认值是 0 。<br>
5.静态大小的数组和 bytes1 到 bytes32 ，每个单独的元素将被初始化为与其类型相对应的默认值。<br>
6.对于动态大小的数组 bytes 和 string 类型，其默认缺省值是一个空数组或空字符串。<br>
7.对于 enum 类型, 默认值是第一个成员。</p>
<h2 id="值类型">值类型</h2>
<h4 id="布尔类型">布尔类型</h4>
<p>bool：可能的取值为字面常量值 true 和 false 。</p>
<h4 id="整型">整型</h4>
<p>int / uint ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 uint8 到 uint256 （无符号，从 8 位到 256 位）以及 int8 到 int256，以 8 位为步长递增。 uint 和 int 分别是 uint256 和 int256 的别名。<br>
<strong>警告</strong><br>
Solidity中的整数是有取值范围的。 例如 uint32 类型的取值范围是 0 到 2 ** 32-1 。 0.8.0 开始，算术运算有两个计算模式：一个是 “wrapping”（截断）模式或称 “unchecked”（不检查）模式，一个是”checked” （检查）模式。 默认情况下，算术运算在 “checked” 模式下，即都会进行溢出检查，如果结果落在取值范围之外，调用会通过 失败异常 回退。 你也可以通过 <code>unchecked { ... }</code> 切换到 “unchecked”模式，更多可参考 unchecked .</p>
<h4 id="定长浮点型">定长浮点型</h4>
<p><strong>警告</strong><br>
Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。<br>
fixed / ufixed：表示各种大小的有符号和无符号的定长浮点型。 在关键字 ufixedMxN 和 fixedMxN 中，M 表示该类型占用的位数，N 表示可用的小数位数。 M 必须能整除 8，即 8 到 256 位。 N 则可以是从 0 到 80 之间的任意数。 ufixed 和 fixed 分别是 ufixed128x19 和 fixed128x19 的别名。</p>
<h4 id="地址类型-address">地址类型 Address</h4>
<p>地址类型有两种形式，他们大致相同：<br>
1.address：保存一个20字节的值（以太坊地址的大小）。<br>
2.address payable ：可支付地址，与 address 相同，不过有成员函数 transfer 和 send 。<br>
这种区别背后的思想是 address payable 可以接受以太币的地址，而一个普通的 address 则不能。<br>
<strong>类型转换:</strong><br>
允许从 address payable 到 address 的隐式转换，而从 address 到 address payable 必须显示的转换, 通过<code>payable(&lt;address&gt;)</code> 进行转换。<br>
address 允许和 uint160、 整型字面常量、bytes20 及合约类型相互转换。<br>
只能通过 payable(...) 表达式把 address 类型和合约类型转换为 address payable。 只有能接收以太币的合约类型，才能够进行此转换。例如合约要么有 receive 或可支付的fallback函数。 注意 payable(0) 是有效的，这是此规则的例外。<br>
<strong>地址类型成员变量</strong><br>
<strong>balance 和 transfer</strong><br>
可以使用 balance 属性来查询一个地址的余额， 也可以使用 transfer 函数向一个可支付地址（payable address）发送 以太币Ether （以 wei 为单位）：</p>
<pre><code class="language-address">address myAddress = this;
if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);
</code></pre>
<p>如果当前合约的余额不够多，则 transfer 函数会执行失败，或者如果以太转移被接收帐户拒绝， transfer 函数同样会失败而进行回退。<br>
<strong>注意</strong><br>
如果 x 是一个合约地址，它的代码（更具体来说是, 如果有receive函数, 执行 receive 接收以太函数, 或者存在fallback函数,执行 Fallback 回退函数 函数）会跟 transfer 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。<br>
当然因为这个特性的存在，我们在设计合约的时候需要考虑到可重入攻击（利用transfer执行之后回调用fallback进入递归反复转账）<br>
<strong>send</strong><br>
send 是 transfer 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 send 会返回 false。<br>
<strong>注意</strong><br>
send 是 transfer 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 send 会返回 false。在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证 以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用接收者自己取回资金的模式。<br>
<strong>call， delegatecall 和 staticcall</strong><br>
为了与不符合 应用二进制接口Application Binary Interface(ABI) 的合约交互，或者要更直接地控制编码，提供了函数 call，delegatecall 和 staticcall 。 它们都带有一个 bytes memory 参数和返回执行成功状态（bool）和数据（bytes memory）。<br>
函数 abi.encode，abi.encodePacked，abi.encodeWithSelector 和 abi.encodeWithSignature 可用于编码结构化数据。</p>
<pre><code class="language-bytes">(bool success, bytes memory returnData) = address(nameReg).call(payload);
require(success);
</code></pre>
<p>此外，为了与不符合 应用二进制接口Application Binary Interface(ABI) 的合约交互，于是就有了可以接受任意类型任意数量参数的 call 函数。 这些参数会被打包到以 32 字节为单位的连续区域中存放。 其中一个例外是当第一个参数被编码成正好 4 个字节的情况。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。</p>
<pre><code class="language-address">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);
nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);
</code></pre>
<p>可以使用gas修改器，调整提供的 gas 数量，也能控制提供的 以太币Ether 的值。 修改器modifier 可以联合使用。每个修改器出现的顺序不重要。</p>
<pre><code class="language-address(nameReg).call{gas:"></code></pre>
<p>以类似的方式，可以使用函数 delegatecall ：区别在于只调用给定地址的代码（函数），其他状态属性如（存储，余额 …）都来自当前合约。 delegatecall 的目的是使用另一个合约中的库代码。 用户必须确保两个合约中的存储结构都适合委托调用 （delegatecall）。</p>
<h4 id="合约类型">合约类型</h4>
<p>1.只有当合约具有 接收receive函数 或 payable 回退函数时，才能显式和 address payable 类型相互转换 转换仍然使用 address(x) 执行， 如果合约类型没有接收或payable 回退功能，则可以使用 payable(address(x)) 转换为 address payable 。<br>
2,.您还可以实例化合约（即新创建一个合约对象）,使用new创建合约。<br>
3.合约类型的成员是合约的外部函数及 public 的 状态变量。<br>
4.对于合约 C 可以使用 type(C) 获取合约的类型信息，</p>
<h4 id="定长字节数组">定长字节数组</h4>
<p>关键字有：bytes1， bytes2， bytes3， …， bytes32。<br>
成员变量：.length 表示这个字节数组的长度（只读）.<br>
可以将 byte[] 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 bytes。</p>
<h4 id="边长字节数组">边长字节数组</h4>
<h4 id="地址字面常量">地址字面常量</h4>
<h4 id="有理数和整数字面常量">有理数和整数字面常量</h4>
<h4 id="字符串字面常量及类型">字符串字面常量及类型</h4>
<h4 id="unicode-字面常量">Unicode 字面常量</h4>
<p>常规字符串文字只能包含ASCII，而Unicode文字（以关键字unicode为前缀）可以包含任何有效的UTF-8序列。 它们还支持与转义序列完全相同的字符作为常规字符串文字。</p>
<pre><code class="language-string"></code></pre>
<h4 id="十六进制字面常量">十六进制字面常量</h4>
<h4 id="枚举类型">枚举类型</h4>
<p>枚举是在Solidity中创建用户定义类型的一种方法。 它们是显示所有整型相互转换，但不允许隐式转换。 从整型显式转换枚举，会在运行时检查整数时候在枚举范围内，否则会导致异常（ Panic异常 ）。 枚举需要至少一个成员,默认值是第一个成员，枚举不能多于 256 个成员。<br>
数据表示与C中的枚举相同：选项从“0”开始的无符号整数值表示。</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.16  &lt;0.9.0;

contract test {
    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
    ActionChoices choice;
    ActionChoices constant defaultChoice = ActionChoices.GoStraight;

    function setGoStraight() public {
        choice = ActionChoices.GoStraight;
    }

    // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，
    // &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。

    function getChoice() public view returns (ActionChoices) {
        return choice;
    }

    function getDefaultChoice() public pure returns (uint) {
        return uint(defaultChoice);
    }
}
</code></pre>
<h4 id="函数类型">函数类型</h4>
<p>1.内部（internal） 函数类型，外部（external） 函数类型，公共函数（public），私有函数（private），函数类型默认是内部函数，因此不需要声明 internal 关键字<br>
2.类型转换：<br>
pure 函数可以转换为 view 和 non-payable 函数<br>
view 函数可以转换为 non-payable 函数<br>
payable 函数可以转换为 non-payable 函数，其他的转换则不可以。<br>
3.public（或 external）函数都有下面的成员：<br>
.address 返回函数的合约地址。<br>
.selector 返回 ABI 函数选择器</p>
<h2 id="引用类型">引用类型</h2>
<p>1.memory 内存即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。<br>
2.存储 storage 状态变量保存的位置，只要合约存在就一直存储．<br>
3.调用数据 calldata 用来保存函数参数的特殊数据位置，是一个只读位置。</p>
<h4 id="数据位置">数据位置</h4>
<h4 id="数据位置与赋值行为">数据位置与赋值行为</h4>
<p>1.在存储storage和内存memory 之间两两赋值（或者从 调用数据calldata 赋值 ），都会创建一份独立的拷贝。<br>
2.从内存memory到内存memory 的赋值只创建引用， 这意味着更改内存变量，其他引用相同数据的所有其他内存变量的值也会跟着改变。<br>
3.从 存储storage 到本地存储变量的赋值也只分配一个引用。<br>
4.其他的向 存储storage 的赋值，总是进行拷贝。 这种情况的示例如对状态变量或 存储storage 的结构体类型的局部变量成员的赋值，即使局部变量本身是一个引用，也会进行一份拷贝。</p>
<h4 id="数组">数组</h4>
<p>1.一个元素类型为 T，固定长度为 k 的数组可以声明为 T[k]，而动态数组声明为 T[]。<br>
2.一个长度为 5，元素类型为 uint 的动态数组的数组（二维数组），应声明为 uint[][5]</p>
<h4 id="创建内存数组">创建内存数组</h4>
<p>1.不能 通过修改成员变量 .push 改变 内存 memory 数组的大小<br>
2.定长的 内存memory 数组并不能赋值给变长的 内存memory 数组<br>
3.</p>
<pre><code class="language-pragma">
contract TX {
    function f(uint len) public pure {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);

        assert(a.length == 7);
        assert(b.length == len);

        a[6] = 8;
    }
}
</code></pre>
<h4 id="数组成员">数组成员</h4>
<p>1.length<br>
2.push() x.push().t = 2 或 x.push() = b<br>
3.push(x) 固定 gas 费用<br>
4.pop 根据现有的数组长度和移除的个数收取 gas 费用</p>
<h4 id="数组切片">数组切片</h4>
<p>1.数组切片是数组连续部分的视图，用法如：x[start:end] ， start 和 end 是 uint256 类型（或结果为 uint256 的表达式）。 x[start:end] 的第一个元素是 x[start] ， 最后一个元素是 x[end - 1] 。<br>
2.目前数组切片，仅可使用于 calldata 数组.</p>
<h4 id="结构体">结构体</h4>
<p>1.和大多数编程语言一样，结构体类型可以作为元素用在映射和数组中，其自身也可以包含映射和数组作为成员变量。<br>
2.在合约外部声明结构体可以使其被多个合约共享。</p>
<h2 id="映射">映射</h2>
<p>映射类型在声明时的形式为 mapping(_KeyType =&gt; _ValueType)。<br>
使用：</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.0 &lt;0.9.0;

contract MappingExample {
    mapping(address =&gt; uint) public balances;

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}

contract MappingLBC {
    function f() public returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(this);
    }
}
</code></pre>
<h4 id="可迭代映射">可迭代映射</h4>
<p>映射本身是无法遍历的，即无法枚举所有的键。不过，可以在它们之上实现一个数据结构来进行迭代。</p>
<pre><code class="language-pragma">
struct IndexValue { uint keyIndex; uint value; } //keyindex 表示key的索引
struct KeyFlag { uint key; bool deleted; }  //key的实际值和删除状态

struct itmap {
    mapping(uint =&gt; IndexValue) data;
    KeyFlag[] keys; //创建一个key的数组来储存KEY的状态
    uint size;
}
</code></pre>
<h4 id="涉及-lvalues-的运算符">涉及 LValues 的运算符</h4>
<p>delete</p>
<pre><code class="language-//">pragma solidity &gt;=0.4.0 &lt;0.9.0;

contract DeleteLBC {
    uint data;
    uint[] dataArray;

    function f() public {
        uint x = data;
        delete x; // 将 x 设为 0，并不影响数据
        delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本
        uint[] storage y = dataArray;
        delete dataArray;
        // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，
        // 因为它是一个存储位置是 storage 的对象的别名。
        // 另一方面：&quot;delete y&quot; 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。
        assert(y.length == 0);
    }
}
</code></pre>
<h4 id="基本类型之间的转换">基本类型之间的转换</h4>
<p>隐式转换<br>
uint8 可以转换成 uint16，int128 转换成 int256，但 int8 不能转换成 uint256<br>
显式转换<br>
如果某些情况下编译器不支持隐式转换，但是你很清楚你要做的结果，这种情况可以考虑显式转换。</p>
<pre><code class="language-uint32">uint16 b = uint16(a); // 此时 b 的值是 0x5678
</code></pre>
<h2 id="字面常量与基本类型的转换">字面常量与基本类型的转换</h2>
<h4 id="整型与字面常量转换">整型与字面常量转换</h4>
<p>十进制和十六进制字面常量可以隐式转换为任何足以表示它而不会截断的整数类型</p>
<pre><code class="language-uint8">uint32 b = 1234; // 可行
uint16 c = 0x123456; // 失败, 会截断为 0x3456
</code></pre>
<h4 id="定长字节数组与字面常量转换">定长字节数组与字面常量转换</h4>
<p>十进制字面常量不能隐式转换为定长字节数组。十六进制字面常量可以是，但仅当十六进制数字大小完全符合定长字节数组长度。 不过零值例外，零的十进制和十六进制字面常量都可以转换为任何定长字节数组类型:</p>
<pre><code class="language-bytes2">bytes2 b = 0x12; // 不可行
bytes2 c = 0x123; // 不可行
bytes2 d = 0x1234; // 可行
bytes2 e = 0x0012; // 可行
bytes4 f = 0; // 可行
bytes4 g = 0x0; // 可行
</code></pre>
<p>字符串字面常量和十六进制字符串字面常量可以隐式转换为定长字节数组，如果它们的字符数与字节类型的大小相匹配:</p>
<pre><code class="language-bytes2">bytes2 b = &quot;xy&quot;; // 可行
bytes2 c = hex&quot;12&quot;; // 不可行
bytes2 d = hex&quot;123&quot;; // n不可行
bytes2 e = &quot;x&quot;; // 不可行
bytes2 f = &quot;xyz&quot;; // 不可行
</code></pre>
<h4 id="地址类型">地址类型</h4>
<p>从 bytes20 或其他整型显示转换为 address 类型时，都会作为 address payable 类型。<br>
一个地址 address a 可以通过payable(a)　转换为　 address payable 类型.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[合约结构]]></title>
        <id>https://tangminjie.github.io/post/solidity/</id>
        <link href="https://tangminjie.github.io/post/solidity/">
        </link>
        <updated>2022-03-17T15:02:21.000Z</updated>
        <content type="html"><![CDATA[<p><strong>前言</strong><br>
solidity作为以太坊网络中的智能合约编程语言，这个篇章将以合约结构，类型，单位和全局变量，表达式和控制结构，以及合约demo来整理solidity相关的基础内容。</p>
<p><strong>状态变量</strong><br>
状态变量是永久地存储在合约存储中的。</p>
<pre><code class="language-pragma">
contract TinyStorage {
    uint storedXlbData; // 状态变量
    // ...
}
</code></pre>
<p><strong>函数</strong><br>
函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义</p>
<pre><code class="language-//">pragma solidity &gt;0.7.0 &lt;0.9.0;

contract TinyAuction {
    function Mybid() public payable { // 定义函数
        // ...
    }
}
// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
    return x * 2;
}
</code></pre>
<p><strong>函数修改器</strong><br>
函数修改器modifier可以用来以声明的方式修改函数语义。</p>
<pre><code class="language-pragma">
contract MyPurchase {
    address public seller;

    modifier onlySeller() { // 修改器
        require(
            msg.sender == seller,
            &quot;Only seller can call this.&quot;
        );
        _;
    }

    function abort() public onlySeller { // 修改器用法
        // ...
    }
}
</code></pre>
<p><strong>事件 Event</strong><br>
事件是能方便地调用以太坊虚拟机日志功能的接口。</p>
<pre><code class="language-pragma">contract TinyAuction {
    event HighestBidIncreased(address bidder, uint amount); // 事件

    function bid() public payable {
        // ...
        emit HighestBidIncreased(msg.sender, msg.value); // 触发事件
    }
}
</code></pre>
<p><strong>结构体</strong><br>
结构体是可以将几个变量分组的自定义类型。</p>
<pre><code class="language-pragma">
contract TinyBallot {
    struct Voter { // 结构体
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
}
</code></pre>
<p><strong>枚举类型</strong><br>
枚举可用来创建由一定数量的“常量值”构成的自定义类型</p>
<pre><code class="language-pragma">
contract Upchain {
    enum State { Created, Locked, InValid } // 枚举
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://tangminjie.github.io/post/hello-gridea/</id>
        <link href="https://tangminjie.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>