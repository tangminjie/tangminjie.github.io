<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tangminjie.github.io</id>
    <title>Tangminjie&apos;s Blog</title>
    <updated>2022-05-18T15:28:08.141Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tangminjie.github.io"/>
    <link rel="self" href="https://tangminjie.github.io/atom.xml"/>
    <subtitle>个人技术博客，做好当下</subtitle>
    <logo>https://tangminjie.github.io/images/avatar.png</logo>
    <icon>https://tangminjie.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Tangminjie&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[ERC-721A]]></title>
        <id>https://tangminjie.github.io/post/erc-721a/</id>
        <link href="https://tangminjie.github.io/post/erc-721a/">
        </link>
        <updated>2022-05-12T08:14:52.000Z</updated>
        <content type="html"><![CDATA[<p>ERC-721A 是由 Azuki 研发的 ERC-721 实现。ERC-721A，已经运用到了他們发行的 Azuki NFT Collection 中。根据他们的文档介绍，铸造一个NFT 所消耗的 gas fee，相比 OZ ERC721，节省了一倍多，如果是一次mint 5 个，节省的 gas 甚至达到 7 倍。<br>
<img src="https://s2.loli.net/2022/05/12/5lXz4cfLMqEn1Cb.png" alt="gas费用对比" loading="lazy"></p>
<h1 id="erc-721a优化">ERC-721A优化</h1>
<p><strong>优化 1 - 从 OpenZeppelin (OZ) ERC721Enumerable 中删除重复存储</strong><br>
IERC721Enumerable 的广泛使用的 OZ 实现包括每个令牌元数据的冗余存储。这种非规范化的方法以编写函数的巨大成本优化读取函数，考虑到用户不太可能为读取函数付费，这并不理想。此外，我们的令牌从 0 开始编号，这一事实让我们从基本实现中删除了一些冗余存储。我们强烈建议所有新发布的产品在寻找大赢家时仔细检查此文件。<br>
ERC721Enumerable接口提供了读取NFT发现量，持有者，TokenID等情况，由智能合约来实现：</p>
<pre><code class="language-totalSupply():">tokenByIndex(): //返回指定位置NFT的TokenID
tokenOfOwnerByIndex(): //返回指定地址的所有TokenID
</code></pre>
<p>首先 ERC721a 对 ERC721Enumerable 中的实现做了优化，去除了一些不必要的存储。<br>
OZ ERC721Enumerable:</p>
<pre><code class="language-//">uint256[] private _allTokens;
/**
  * @dev See {IERC721Enumerable-totalSupply}.
  */
function totalSupply() public view virtual override returns (uint256) {
   return _allTokens.length;
}
</code></pre>
<p>Azuki ERC721a:</p>
<pre><code class="language-uint256">/**
  * @dev See {IERC721Enumerable-totalSupply}.
  */
function totalSupply() public view override returns (uint256) {
    return currentIndex;
}
</code></pre>
<p>可以看到相比 OZ ERC721Enumerable， Azuki ERC721a 沒有使用昂贵的 array 存储空间來保存 allTokens， 而是直接用 currentIndex 來返回（之所以能这样做是因为 Azuki ERC721a 的所有 tokenID 都是从 0 开始，逐个增长）。<br>
<strong>Storage 存储空间的优化</strong><br>
在 @openzeppelin/ERC721Enumerable 实现中，为了方便读取 NFT 的所有者信息，做了许多冗余的元数据存储，作为代价，在 mint 函数内，则需要额外的开销来存储这些信息。而 ERC721A 实现则相反，将所占的必须存储压缩到了最小，这样虽然增加了读取操作的复杂度，但是，读取是免费的。<br>
@openzeppelin/ERC721Enumerable 中所用的存储：</p>
<pre><code class="language-abstract">    //存储钱包地址==&gt;(tokenIDindex==&gt;tokenID)
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) private _ownedTokens;
    //保存了该 NFT ID 到用户拥有索引的映射,如_ownedTokensIndex[201] = 0 表示 ID 为      201 的该 NFT 是所属用户的拥有列表中的第一个。
    mapping(uint256 =&gt; uint256) private _ownedTokensIndex;
    //表示了所以被 mint 出来的该 NFT 的 ID 列表。
    uint256[] private _allTokens;
    //表示了具体某个 ID 的 NFT 在 _allTokens 列表中的位置
    mapping(uint256 =&gt; uint256) private _allTokensIndex;
    // ...
}
</code></pre>
<p>而在 ERC721A 的实现中，去除了那两个冗余索引：</p>
<pre><code class="language-contract">    Context,
    ERC165,
    IERC721,
    IERC721Metadata,
    IERC721Enumerable
{
  struct TokenOwnership {
      address addr;
      uint64 startTimestamp;
  }

  struct AddressData {
      uint128 balance;
      uint128 numberMinted;
  }
//ID =&gt; 钱包地址
  mapping(uint256 =&gt; TokenOwnership) private _ownerships;
//钱包地址 =&gt; 所有数量
  mapping(address =&gt; AddressData) private _addressData;

  // ...
}
</code></pre>
<p><strong>优化 2 - 每个批次铸币请求更新所有者的余额一次，而不是每个铸币 NFT</strong><br>
假设 Alice 有 2 个代币并想再购买 5 个。在 Solidity 中，更新储值需要消耗 gas。因此，如果我们在存储中跟踪 Alice 拥有多少代币，那么通过一次更新将 Alice 的持有量从 2 直接更新到 7 会更便宜，而不是将该值更新 5 次（在OZ中需要逐个mint，并且每个额外的代币增加一次，从 2 到 3、3到 4 等）。<br>
虽然这是一个相对简单的概念，但 NFT 领域的绝大多数批量铸币厂还没有采用这一点，因为 OZ 默认实现不包括批量铸币厂 API，并且很容易在不调整的情况下从现成的现有解决方案中获取它. 我们强烈建议所有支持批量铸币的项目都考虑这个技巧。<br>
Azuki ERC-721A mint function：</p>
<pre><code class="language-function">    address to,
    uint256 quantity,
    bytes memory _data
) internal {
    uint256 startTokenId = currentIndex;
    
    ...
    AddressData memory addressData = _addressData[to];
    _addressData[to] = AddressData(
        addressData.balance + uint128(quantity),
        addressData.numberMinted + uint128(quantity)
    );
    _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));
    uint256 updatedIndex = startTokenId;
    for (uint256 i = 0; i &lt; quantity; i++) {
        emit Transfer(address(0), to, updatedIndex);
        require(
            _checkOnERC721Received(address(0), to, updatedIndex, _data),
            &quot;ERC721A: transfer to non ERC721Receiver implementer&quot;
        );
        updatedIndex++;
    }
    currentIndex = updatedIndex;
    _afterTokenTransfers(address(0), to, startTokenId, quantity);
}
</code></pre>
<p>这样一来，ERC721A 做到了就把对 storage 的写入从 O(N) 优化到了 O(1) 。单次 mint 的数量越多，优化效果则越明显。<br>
<strong>优化 3 - 每个批次铸币请求更新一次所有者数据，而不是每个铸币 NFT</strong><br>
这在精神上类似于优化 2。假设 Alice 想购买 3 个代币 - 代币 #100、#101 和 #102。与其将 Alice 保存为所有者 3 次（每次都要花费我们的 gas），我们可以改为只保存一次所有者值，这种方式在语义上意味着 Alice 拥有所有 3 个令牌。<br>
如何？假设 Alice 铸造代币 #100、#101 和 #102，而 Bob 铸造代币 #103 和 #104。内部所有者跟踪器如下所示：<br>
<img src="https://s2.loli.net/2022/05/12/ZTHS6cOinkMuaNx.png" alt="token队列.png" loading="lazy"><br>
这里的关键是，如果我们想查看谁拥有 #102，我们实际上不需要将 Alice 明确设置为 #102 的明确所有者。我们可以更改 ownerOf 函数来执行以下操作：<br>
<img src="https://s2.loli.net/2022/05/12/eFEXUnH49qN3WJG.png" alt="OwnerOf.png" loading="lazy"><br>
关键见解：如果我们将其实现更改为递减，直到它找到明确的所有者集，ownerOf 仍然按预期工作。<br>
虽然如果代币不是 HODL 的话，这些延迟的所有者写入可能仍会在代币生命周期的后期发生，但我们仍然期望从整体上节省大量净成本，因为这可以减少铸币厂的 gas 消耗，从而降低集中 gas 的严重性薄荷时间整个生态系统的峰值。这种优化涉及一些额外的逻辑，特别是在传输方面，</p>
<h1 id="erc-721a存在的问题">ERC-721A存在的问题</h1>
<p>因为Azuki ERC-721A中TokenID必须要保持连续性为基础，所以目前Azuki ERC-721A并没有提供 burn Token 功能。所以要使用类似销毁NFT的功能，Azuki ERC-721A则不试用。如果你的需求是TokenID是随机数，那么Azuki ERC-721A也不适用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多签钱包]]></title>
        <id>https://tangminjie.github.io/post/duo-qian-qian-bao/</id>
        <link href="https://tangminjie.github.io/post/duo-qian-qian-bao/">
        </link>
        <updated>2022-05-10T09:33:35.000Z</updated>
        <content type="html"><![CDATA[<p>多签钱包最大的特点是需由多个私钥持有者的授权才能进行钱包交易。通常情况下，多签钱包在创建时便需确认好“m-n模式”，即创建总计n个私钥，并通过这n个私钥计算生成一个钱包地址，只有这n个私钥中的m个持有者共同签名授权才能完成对该钱包地址所对应的加密货币的相关操作。2-3是多签钱包中最常见的运作模式，即每次交易都需全部3个私钥中的2个进行签名授权才能完成，能够较好地平衡安全性与便捷性之间的关系。<br>
<strong>多签钱包得优势：</strong><br>
在单签钱包中，决定加密货币所有权和管理权的私钥仅掌握在单人手中，一旦私钥丢失或持有者遗忘钱包助记词，那就意味着持有者失去了对该钱包地址的控制权，与其相关联的加密资产将完全丢失。<br>
而多签钱包的存在，最大程度降低了单个私钥丢失时的资产损失风险。以2-3模式为例，在全部3个私钥中，只要有2个私钥完成了签名授权操作就能进行相关加密货币的交易。即使有1个私钥丢失，还能通过剩下的2个私钥完成对资产的转移，避免资产损失。<br>
多签钱包的地址是由多个私钥通过计算生成的，这一机制相比单签钱包要复杂得多。因此，对比单签钱包，黑客要想攻击钱包地址并盗取钱包内的加密货币资产，就得破解多个私钥，这一难度是成倍增长的。多签的机制保障了钱包本身在面对外部攻击时的安全性。</p>
<h1 id="ownbit-和-gnosis">Ownbit 和 Gnosis</h1>
<p>Ownbit 和 Gnosis 是市场上用户量相对最多得两个多签钱包。<br>
Ownbit 和 Gnosis 均通过合约账户实现以太坊多签，但是其实现的逻辑却迥然不同。分别代表了当前两种主流的实现方式，我们通过合约源码来讲解实现原理和各自的优缺点。</p>
<h2 id="gnosis-实现多签逻辑">Gnosis 实现多签逻辑</h2>
<p>Gnosis 实现多签逻辑的过程如下：<br>
1.任意一方通过 submitTransaction 方法提交交易，得到一个交易号（transactionId，该交易号并非我们常见的交易哈希，而是一个自增长的 uint256）：</p>
<pre><code class="language-function">        public
        returns (uint transactionId)
    {
        transactionId = addTransaction(destination, value, data);
        confirmTransaction(transactionId);
    }
</code></pre>
<p>2.其他参与方提交 ETH 交易，调用合约的 confirmTransaction 方法，来表示他们对某个交易执行的认可：</p>
<pre><code class="language-function">        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
{
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
</code></pre>
<p>3.当 confirm 的人数达到最低（_required）要求，executeTransaction 的内部逻辑将被触发，从而执行第一步用户所提交的逻辑（value 和 data）：</p>
<pre><code class="language-function">        public
        notExecuted(transactionId)
    {
        if (isConfirmed(transactionId)) {
            Transaction tx = transactions[transactionId];
            tx.executed = true;
            if (tx.destination.call.value(tx.value)(tx.data))
                Execution(transactionId);
            else {
                ExecutionFailure(transactionId);
                tx.executed = false;
            }
        }
    }
</code></pre>
<h2 id="ownbit-实现多签逻辑">Ownbit 实现多签逻辑</h2>
<p>Ownbit 实现多签的逻辑和 Gnosis 不同。可以认为 Gnosis 的实现逻辑为线上方式，而 Ownbit 的实现逻辑为线下方式。<br>
1.相关参与方（满足 _required 个数）线下对即将执行的交易进行签名（所谓线下，即这个过程不需要向以太坊发送交易），生成签名结果（r、v、s）：</p>
<pre><code class="language-function">    //the sequence should match generateMultiSigV2 in JS
    bytes32 message = keccak256(abi.encodePacked(address(this), erc20Contract, destination, value, spendNonce));
    return message;
  }
</code></pre>
<p>参与签名的参数有：多签合约地址、Erc20代币合约地址（对于转移 ether 使用 0x0）、转移的目标地址、金额、控制重放的合约内部 spendNonce。<br>
对以上参数签名，表示参与方同意对指定合约转移指定金额。<br>
2.任意一方（甚至可以是多签参与方以外的其他人）发送 ETH 交易，调用合约的 spend 或 spendERC20 方法，并将以上签名结果作为参数传入：</p>
<pre><code class="language-function">    require(destination != address(this), &quot;Not allow sending to yourself&quot;);
    //transfer erc20 token
    //uint256 tokenValue = Erc20(erc20contract).balanceOf(address(this));
    require(value &gt; 0, &quot;Erc20 spend value invalid&quot;);
    require(_validSignature(erc20contract, destination, value, vs, rs, ss), &quot;invalid signatures&quot;);
    spendNonce = spendNonce + 1;
    // transfer tokens from this contract to the destination address
    Erc20(erc20contract).transfer(destination, value);
    emit SpentERC20(erc20contract, destination, value);
  }
</code></pre>
<p>_validSignature 将对签名的有效性进行验证。验证通过的情况下，相关转币逻辑即被执行。<br>
以上便完成了 Ownbit 多签合约的调用。Ownbit 将不同目的分解到不同的方法中，例如：spend 进行 ether 转移，spendERC20 进行 Erc20 代币转移，spendAny 进行任意功能的调用。</p>
<h2 id="两种方式的优缺点">两种方式的优缺点</h2>
<p>以上两种实现 ETH 多签的不同方式，具有很好的代表性。这也是目前实现 ETH 多签最常用的两种手段。<br>
<strong>Gnosis 方式的优点：</strong><br>
1.采用发送交易来表示参与方同意某个花费或调用，避免了复杂的签名计算；<br>
2.全程线上，具有更好的审计性（参与方的 Reject 的态度也保留在区块链上）；<br>
<strong>Gnosis 方式的主要缺点：</strong><br>
1.每个参与方都需向线上发送交易，多次花费手续费，不经济；<br>
2.每个参与方所花费的手续费不均等，使 confirm 人数刚好等于 _required 的交易将花费更大的手续费以执行 executeTransaction 内部逻辑；<br>
3.交易逻辑隐藏在 data 里，可欺骗性大；<br>
<strong>Gnosis 方法的优点正是 Ownbit 方法的缺点，Gnosis 方法的缺点也是 Ownbit 方法的优点。总体而言，Ownbit 的方法因为其经济性，使用得更多。</strong></p>
<h1 id="基于solidity0813实现gnosis合约逻辑">基于solidity0.8.13实现Gnosis合约逻辑</h1>
<p>github:<br>
https://github.com/tangminjie/learnblockchain/tree/main/Multi-Sig-Wallet</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习资料]]></title>
        <id>https://tangminjie.github.io/post/xue-xi-zi-liao/</id>
        <link href="https://tangminjie.github.io/post/xue-xi-zi-liao/">
        </link>
        <updated>2022-05-06T06:25:10.000Z</updated>
        <content type="html"><![CDATA[<p><strong>solidity实例</strong><br>
https://solidity-by-example.org/</p>
<p><strong>learnWeb3官网</strong><br>
https://www.learnweb3.io/</p>
<p><strong>Dapp-learning-dao</strong><br>
学习组织很全面的学习资料以及项目路径<br>
https://github.com/Dapp-Learning-DAO</p>
<p><strong>登链社区</strong><br>
中文社区，比较全面的中文文档<br>
https://learnblockchain.cn</p>
<p><strong>登链集训营资料</strong><br>
https://learnblockchain.cn/video/play/300</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AMM原理，滑点，和无偿损失]]></title>
        <id>https://tangminjie.github.io/post/amm-yuan-li-hua-dian-he-wu-chang-sun-shi/</id>
        <link href="https://tangminjie.github.io/post/amm-yuan-li-hua-dian-he-wu-chang-sun-shi/">
        </link>
        <updated>2022-04-29T08:47:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="amm自动化做市商">AMM自动化做市商</h1>
<p>DeFi领域去中心化交易所DEX能够崛起的一个核心原因是引入了自动做市商（AMM）模式。AMM又称自动化做市商，它是去中心化交易所（DEX）最为关键的技术之一，已被证明是最具影响力的DeFi创新之一，它们能够为一系列不同代币创建和运行可公开获取的链上流动性。<br>
任何市场都可能存在没有足够的有机流动性以支持活跃的交易的状况，做市商本质上就是通过促进这些市场中不会发生的交易来缓解这一问题的代理商。在传统的CEX里许多做市商都是专业的团队或是机构。而AMM(Automated Market Maker)，相当于把他们这个角色给真正的去中心化了。<br>
每个用户都可以把自己的代币扔到流动池里，成为一个小的做市商，然后享受交易对手续费分红。且流动池资金是去中心化开源合约控制，AMM交易数据全部上链，不像传统CEX的平台币销毁或是分红，毕竟没有人知道他们手续费真的挣了多少，平台币流通了多少等等。而在AMM这里，一切透明。更重要的是，你的资产依旧在你个人控制的钱包里，而不是进了交易平台，所以资产依旧100%安全，这是传统CEX无论如何不可能实现的。</p>
<h2 id="amm实现原理">AMM实现原理</h2>
<p>AMM通过数学公式对资产进行定价。资产定价通过定价算法完成，不再使用传统交易平台常用的订单簿。定价公式随不同协议而变化。例如，Uniswap使用的公式为x * y= k，其中x代表流动性资金池中一种代币的数量，y则表示另一种代币的数量。在此公式中，k是一个固定常数，表明池中的流动性总量必须保持不变。<br>
我们假设UNISWAP一个交易池中是ETH－DAI，第一个流动性提供者放进去了ａ个ETH和b个DAI。这时候这个交易对，对应的初始值是 x＝ａ， y＝ｂ；那K的初始值＝ａ＊ｂ；<br>
此时ETH的价格就是b/a，DAI的价格＝a/b；在K不变的情况下，如果这个交易池有trader T进来，想用ｗ个EHT换DAI。他会以什么样的价格拿到多少DAI呢？<br>
在恒定乘积下，这个运算过程是这样的：<br>
<code>y’=K/(x+ｗ)</code><br>
其中y’等于此次交易后，交易池中的DAI的个数。由此可知，T得到的DAI的个数=y-y’;这些DAI的价格=w/(y-y’).<br>
所以你发现了吗？在交易者告诉平台自己要兑换的数量之前，他能拿到什么价格是不确定的。这就让UNISWAP的价格获取跟中心化交易所和利用价格预言机的交易所完全区分开了。<br>
还有别忘了，我们假定的前提条件是K不变，那哪些情况下K值是要改变的？答案有二，一是交易费，二是流动性。<br>
<strong>交易费</strong><br>
用户每一次的交易，需要交0.3%的手续费。拿上面交易举例，我们为了简化计算忽略了手续费，真实的情况是uniswap平台在计算出y’后会扣除0.3%y’的手续费，完成交易后，这0.3%dy会被添加到流动性池里，此时K值就变成了 xy+x0.3%y’=x*(y+0.3%y).<br>
所以，你发现了吗？K值变大了。反之亦然，减少流动性，会减少K值。换言之，恒定乘积算法的K值并不恒定，每一笔交易都会影响K值。<br>
<strong>流动性</strong><br>
流动性是怎么改变K值的呢？当第二个人在一个交易对中按照比例增加了ETH和DAI的数量，X和Y就同时增加了，很显然，K的值就是增加的；如果第一个人取走自己的交易对，K值就减少，非常简单。</p>
<h2 id="滑点">滑点</h2>
<p>滑点是指成交价与下单时的预期价不同，通常是由于从下单到成交时的价格变动造成的。当我们在dex上交易的时候可以手动设置滑点。当交易价格超过我们可以接受的滑点范围时交易会失败。<br>
<strong>怎样才能避免滑点</strong><br>
1.我们无法完全避免滑点，但可以减少滑点带来的风险，将损失降到最低。首先，只在具有良好流动性和完善基础设施的平台上进行交易。最好的办法是选择高交易量、高流动性的钱币。<br>
2.可以选择更容易成交的小额交易，而不是一下子下一笔大单。如果你下的单超过了现有的流动性下DEX是无法撮合交易的。如果把大单分解成几个小单，就更有可能成交，不会有流动性不足的情况。</p>
<h1 id="无偿损失">无偿损失</h1>
<p>在DEFI协议中我们可以组LP来为流动池提供流动性，以收取挖矿收益或者手续费收益。例如UNISWAP中的0.3%的手续费会按LP比例来分配收益。因提供流动性需要将两种代币质押到LP池子，如果两个代币的价格发生波动，根据恒定乘积公式 X*Y=K，质押的代币数量会发生变化，按U本位计价在比价波动前后，会承担额外的损失，这部分额外损失就是我们常说的无常损失。</p>
<pre><code>以ETH/USDT这个交易对为例，在ETH价格为$500时，我们可以提供这样的资金：
ETH： 20枚
USDT： $10,000
总值： $20,000 这是池中的所有的资金。
x*x*eth单价=20000
如果ETH的外部价格上涨到$550，就会有投机者来这里买入便宜的ETH，并把价格推高到$550。
按 x * y = k 的Uniswap自动做市商公式：
20 * 10,000 = 200,000 （ETH=$500）
19.07 * 10488 = 200,000（ETH=$550）
投机者可以用$488来买走0.93ETH，从而把价格推高到跟市场一致。而他的成本是：ETH=$524.7，有一定的套利空间。
在新的状态下（ETH=$550），对于LP来说
ETH：19.07枚
USDT：$10488
总值：$20976
但是，如果我们这一对ETH/USDT资金没有来放入流动性池，情况是：
总值：$21000
因此，因为ETH上涨，我们损失了$24。这就是无常损失。
如果ETH价格跌到了$400，情况会怎么样呢？
按 x * y = k 的Uniswap自动做市商公式：
20 * 10,000 = 200,000 （ETH=$500）
22.36 * 8944 = 200,000（ETH=$400）
在新的状态下（ETH=$400），对于LP来说
ETH：22.36枚
USDT：$8944
总值：$17888
但是，如果我们这一对ETH/USDT资金没有来放入流动性池，情况是：
总值：$18000
因此，因为ETH下跌，我们损失了$112。也就是说，价格下跌，我们也会遭遇无常损失。唯有价格不动，LP才不会有无常损失。
</code></pre>
<p>当我们把一对ETH/USDT存入流动性池子中，变化是：<br>
● 当ETH价格上涨时，系统实际上帮我们自动卖出ETH。<br>
● 当ETH价格下跌时，系统实际上帮我们自动买入ETH。<br>
因此，我们的第一选择是做稳定币池的LP，因为它们之间价格几乎没有波动，其次是做ETH/BTC的LP，因为二者之间往往是同向的，比整体市场波动小。<br>
总的来说，流动性提供者承受了无常损失，提供了流动性服务，并因无常损失而获得了相应的回报</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[委托调用与合约升级-1]]></title>
        <id>https://tangminjie.github.io/post/wei-tuo-diao-yong-yu-he-yue-sheng-ji-1/</id>
        <link href="https://tangminjie.github.io/post/wei-tuo-diao-yong-yu-he-yue-sheng-ji-1/">
        </link>
        <updated>2022-04-26T09:13:58.000Z</updated>
        <content type="html"><![CDATA[<p>在传统的WEB2开发中我们习惯对产品进行升级迭代，这也是必要的，因为在开发中我们要经常进行BUG的修复和新特性的更新。但是在智能合约中，我们部署上去的合约数据一旦上链就无法隐藏和更改。这也是以太坊去中心化的核心。<br>
但是随之而来的问题也很明显，当合约部署到链上之后，就再也无法改变源码。  当部署的合约存在bug或者安全漏洞时（合约审计并没有十分完善的代码审核）。在早期就只能重新部署合约，或者引入一个新的合约并且将数据迁移。这都会改变合约的地址，对于社区或者投资人和项目本身都是不利的。<br>
所以后来引入了合约升级方案。</p>
<h1 id="委托调用">委托调用</h1>
<p>在合约升级之前我们必须要知道的一个概念就是委托调用。这也是合约升级能够实现的一个重要技术点。<br>
在编写 Ethereum SmartContract 代码时，在某些情况下我们需要与其他合约进行交互。在Solidity 中，为此目的，有几种方法可以实现这一目标。<br>
**  1.如果我们知道目标合约 ABI，我们可以直接使用函数签名  **<br>
假设我们部署了一个名为“Storage”的简单合约，允许用户保存一个值。</p>
<pre><code class="language-pragma">contract Storage {
    uint public val;
constructor(uint v) public {
        val = v;
    }
function setValue(uint v) public {
        val = v;
    }
}
</code></pre>
<p>我们要部署另一个名为“Machine”的合约，它是“Storage”合约的调用者。“Machine”引用“Storage”合约并更改其值。</p>
<pre><code class="language-pragma">import &quot;./Storage.sol&quot;;
contract Machine {
    Storage public s;
constructor(Storage addr) public {
        s = addr;
        calculateResult = 0;
    }
    
    function saveValue(uint x) public returns (bool) {
        s.setValue(x);
        return true;
    }
function getValue() public view returns (uint) {
        return s.val();
    }
}
</code></pre>
<p>在这种情况下，我们知道“Storage”的ABI及其地址，这样我们就可以用该地址初始化现有的“Storage”合约，ABI告诉我们如何调用“Storage”合约的函数。我们可以看到“Machine”合约调用“Storage”setValue()功能。<br>
并编写测试代码检查“Machine”是否saveValue()真的调用了“Storage”setValue()函数并改变其状态。</p>
<pre><code class="language-const">const MachineFactory = artifacts.require('Machine');
contract('Machine', accounts =&gt; {
  const [owner, ...others] = accounts;
beforeEach(async () =&gt; {
    Storage = await StorageFactory.new(new BN('0'));
    Machine = await MachineFactory.new(Storage.address);
  });
describe('#saveValue()', () =&gt; {
    it('should successfully save value', async () =&gt; {
      await Machine.saveValue(new BN('54'));
      (await Storage.val()).should.be.bignumber.equal(new BN('54'));
    });
  });
});
</code></pre>
<p>查看测试结果：</p>
<pre><code class="language-Contract:">  After initalize
    #saveValue()
      ✓ should successfully save value (56ms)
1 passing (56ms)
</code></pre>
<p>**  2.如果我们不知道目标合约 ABI，请使用 call 或 delegatecall  **<br>
在解释以太坊 Solidity中call()和delegatecall()之前，先看看 EVM 如何保存合约的变量。<br>
**  EVM 如何将字段变量保存到 Storage  **<br>
在以太坊中，保存合约字段变量的空间有两种。一个是“memory”，另一个是“storage”。storage声明的数据会永久的储存在区块链上。<br>
那么单个合约中的这么多变量怎么可能不重叠彼此的地址空间呢？EVM 将槽号分配给字段变量。</p>
<pre><code class="language-contract">    uint256 first;  // slot 0
    uint256 second; // slot 1
}
</code></pre>
<p>因为first首先在“Sample1”中声明，所以它被分配了 0 个插槽。每个不同的变量由它的槽号来区分。<br>
在 EVM 中，它在智能合约存储中有 2²⁵⁶ slot，每个 slot 可以保存 32 字节大小的数据。<br>
**  call和delegatecall的区别  **<br>
call委托调用是用户地址调用代理合约去调用业务合约，修改的是被调用者的storage，并且被调用合约的msg.sender是代理合约。<br>
delegatecall 是修改的代理合约本身的storage，并且被调用合约的msg。sender是用户地址。<br>
可以理解成delegatecall只是使用了业务合约的接口，所有的数据状态变化全都是代理合约本身。<br>
**  测试用例  **<br>
注意：在使用delegatecall的时候要十分注意调用者合约和委托调用合约之间变量字段的顺序，这涉及到合约的插槽顺序，我们用一个例子来说明：<br>
首先编码一个调用者合约：</p>
<pre><code class="language-pragma">import &quot;./Storage.sol&quot;;
contract Machine {
    Storage public s;
    
    uint256 public calculateResult;
    
    address public user;
  
    event AddedValuesByDelegateCall(uint256 a, uint256 b, bool success);
    event AddedValuesByCall(uint256 a, uint256 b, bool success);
    
    constructor(Storage addr) public {
        ...
        calculateResult = 0;
    }
    
  ...
    
    function addValuesWithDelegateCall(address calculator, uint256 a, uint256 b) public returns (uint256) {
        (bool success, bytes memory result) = calculator.delegatecall(abi.encodeWithSignature(&quot;add(uint256,uint256)&quot;, a, b));
        emit AddedValuesByDelegateCall(a, b, success);
        return abi.decode(result, (uint256));
    }
    
    function addValuesWithCall(address calculator, uint256 a, uint256 b) public returns (uint256) {
        (bool success, bytes memory result) = calculator.call(abi.encodeWithSignature(&quot;add(uint256,uint256)&quot;, a, b));
        emit AddedValuesByCall(a, b, success);
        return abi.decode(result, (uint256));
    }
}
</code></pre>
<p>委托调用合约：</p>
<pre><code class="language-pragma">contract Calculator {
    uint256 public calculateResult;
    
    address public user;
    
    event Add(uint256 a, uint256 b);
    
    function add(uint256 a, uint256 b) public returns (uint256) {
        calculateResult = a + b;
        assert(calculateResult &gt;= a);
        
        emit Add(a, b);
        user = msg.sender;
        
        return calculateResult;
    }
}
</code></pre>
<p>测试脚本：</p>
<pre><code class="language-describe('#addValuesWithDelegateCall()',">  let Calculator;
  
  beforeEach(async () =&gt; {
    Calculator = await CalculatorFactory.new();
  });
  
  it('should successfully add values with delegate call', async () =&gt; {
    const result = await Machine.addValuesWithDelegateCall(Calculator.address, new BN('1'), new BN('2'));
expectEvent.inLogs(result.logs, 'AddedValuesByDelegateCall', {
      a: new BN('1'),
      b: new BN('2'),
      success: true,
    });
(result.receipt.from).should.be.equal(owner.toString().toLowerCase());
    (result.receipt.to).should.be.equal(Machine.address.toString().toLowerCase());
// Calculator storage DOES NOT CHANGE!
    (await Calculator.calculateResult()).should.be.bignumber.equal(new BN('0'));
    
    // Only calculateResult in Machine contract should be changed
    (await Machine.calculateResult()).should.be.bignumber.equal(new BN('3'));
(await Machine.user()).should.be.equal(owner);
    (await Calculator.user()).should.be.equal(constants.ZERO_ADDRESS);
  });
});
</code></pre>
<p>我们想要测试的是：<br>
1.因为上下文在“Calculator”而不是“Machine”上，所以添加结果应该保存到“Calculator”存储中。<br>
2.Calculator  calculateResult应该是0，user.address应该是0地址。<br>
3.Machine calculateResult应该是3，user是EOA。<br>
但是允许TEST的结果是我们失败了：</p>
<pre><code class="language-0">1 failing
1) Contract: Machine
     After initalize
       #addValuesWithDelegateCall()
         should successfully add values with delegate call:
AssertionError: expected '562046206989085878832492993516240920558397288279' to equal '3'
    + expected - actual
-562046206989085878832492993516240920558397288279
    +3
    ```
正如我们之前提到的，每个字段变量都有自己的插槽。而当我们委托调用“Calculator”时，上下文在“Machine”上，但槽号基于“Calculator”。因此，因为“计算器”逻辑用 覆盖地址Storage，calculateResult所以测试失败。
基于这些知识，我们可以找到“562046206989085878832492993516240920558397288279”的来源。它是 EOA 的十进制版本。
所以要解决这个问题，我们需要改变“Machine”字段变量的顺序。使它和“Calculator”插槽对应：
```  uint256 public calculateResult;
    
    address public user;
    
    Storage public s;
</code></pre>
<p>总结：<br>
如果我们知道目标函数的ABI，我们可以直接使用目标函数签名<br>
如果我们不知道目标函数的 ABI，我们可以使用call(), 或delegatecall(). 但是在 的情况下delegatecall()，我们需要关心字段变量的顺序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[委托调用与合约升级-2]]></title>
        <id>https://tangminjie.github.io/post/wei-tuo-diao-yong-yu-he-yue-sheng-ji-2/</id>
        <link href="https://tangminjie.github.io/post/wei-tuo-diao-yong-yu-he-yue-sheng-ji-2/">
        </link>
        <updated>2022-04-26T09:13:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="合约升级">合约升级</h1>
<p>**  合约升级的三种模式： **<br>
1.继承存储模式 Inherited Storage<br>
2.永久存储模式 Eternal Storage<br>
3.非结构化存储模式 Unstructured Storage</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ABI编码函数]]></title>
        <id>https://tangminjie.github.io/post/abi-bian-ma-han-shu/</id>
        <link href="https://tangminjie.github.io/post/abi-bian-ma-han-shu/">
        </link>
        <updated>2022-04-26T07:51:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是abi">什么是abi</h1>
<p>ABI-Application Binary Interface，应用二进制接口说明。<br>
ABI可以简单理解成区块链外部与合约进行交互以及合约和合约之间进行交互的一种标准方式。数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。在以太坊中主要用于solidity合约的函数调用，以及反向编码读取数据的中的方法。</p>
<h1 id="solidityabi编码函数">solidityABI编码函数</h1>
<pre><code class="language-abi.encode(…)">abi.encodePacked(…) returns (bytes)：计算参数的紧密打包编码
abi. encodeWithSelector(bytes4 selector, …) returns (bytes)： 计算函数选择器和参数的 ABI 编码
abi.encodeWithSignature(string signature, …) returns (bytes): 等价于* abi.encodeWithSelector(bytes4(keccak256(signature), …)
</code></pre>
<h2 id="solidityabi编码函数-实现细节">solidityABI编码函数 实现细节</h2>
<pre><code class="language-函数选择器，官方文档定义如下：">一个函数调用数据的前 4 字节，指定了要调用的函数。这就是某个函数签名的 Keccak（SHA-3）哈希的前 4 字节（高位在左的大端序）（译注：这里的“高位在左的大端序“，指最高位字节存储在最低位地址上的一种串行化编码方式，即高位字节在左）。 这种签名被定义为基础原型的规范表达，基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。
</code></pre>
<p>简单来说，函数选择器就是通过函数名来参数来标识函数，可以用于不同合约之间的函数调用。<br>
合约中函数调用截取调用数据的前四个字节（0x之后），就是将函数名以及参数类型进行签名处理（Keccak–Sha3）。</p>
<h2 id="solidityabi编码函数实现">solidityABI编码函数实现：</h2>
<pre><code class="language-contract">    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function abiEncode(uint x) public view returns (bytes memory) {
        abi.encode(x);  // 计算1的ABI编码
        return abi.encodeWithSignature(&quot;set(uint256)&quot;, x); //计算函数set(uint256) 及参数1 的ABI 编码
    }
}
</code></pre>
<p>remix部署合约之后，调用abiEncode()将会产生如下数据输出：<br>
abi.encode(21)<br>
0x60fe47b10000000000000000000000000000000000000000000000000000000000000015<br>
其中60fe47b1便是对应的set()函数的签名处理：</p>
<pre><code class="language-["> {
 	&quot;constant&quot;: false,
 	&quot;inputs&quot;: [
 		{
 			&quot;internalType&quot;: &quot;uint256&quot;,
 			&quot;name&quot;: &quot;value&quot;,
 			&quot;type&quot;: &quot;uint256&quot;
 		}
 	],
 	&quot;name&quot;: &quot;set&quot;,
 	&quot;outputs&quot;: [],
 	&quot;payable&quot;: false,
 	&quot;stateMutability&quot;: &quot;nonpayable&quot;,
 	&quot;type&quot;: &quot;function&quot;
 }
]
</code></pre>
<p>传入参数为21 对于16进制为15,合约函数名与函数参数，每个参数最终要被补全为32个字节。<br>
**  abiDetail:  **</p>
<pre><code class="language-constant">type: 调用参数类型： string，function，callback，contsructor
name: 调用参数名称
payable： 是否支持ether
stateMutability:(状态可变性) - pure - view - payable - nonpayable
outputs: 调用输出值
input：{
name: 参数名称
type: 参数类型
}
</code></pre>
<h2 id="abiencode-与abiencodepacked">abi.encode 与abi.encodePacked</h2>
<p>对函数打包处理，但是处理方式不一样，对于小于32字节类型的参数，前者会将所有参数自动补全到32个字节，后者不会自动补全。</p>
<pre><code class="language-function">      bytes memory _bts =&quot;Hello,world!&quot;;
    return (abi.encodePacked(_bts),abi.encode(_bts));
  }
}
output:
0:
bytes: 0x48656c6c6f2c776f726c6421
1:
bytes: 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000c48656c6c6f2c776f726c64210000000000000000000000000000000000000000
</code></pre>
<h2 id="关于使用abiencodewithsignaturestring-signature-returns-bytes">关于使用abi.encodeWithSignature(string signature, …) returns (bytes)</h2>
<p>主要应用场景： 函数调用:</p>
<pre><code class="language-contract">    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function abiEncode() public constant returns (bytes) {
        abi.encode(1);  // 计算1的ABI编码
        return abi.encodeWithSignature(&quot;set(uint256)&quot;, 1); //计算函数set(uint256) 及参数1 的ABI 编码
    }
}
</code></pre>
<h2 id="web3-abi-编码函数">Web3 ABI 编码函数</h2>
<p>另一个web3提供相应的API，例如使用web3计算函数选择器的方式如下：<br>
<code>web3.eth.abi.encodeFunctionSignature('myMethod(uint256,string)');</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ERC-777]]></title>
        <id>https://tangminjie.github.io/post/erc-777/</id>
        <link href="https://tangminjie.github.io/post/erc-777/">
        </link>
        <updated>2022-04-23T09:18:08.000Z</updated>
        <content type="html"><![CDATA[<p>ERC-777 是一个易于交易的通证标准，可改进现有的 ERC-20 标准。<br>
对于ERC-20协议标准存在以下缺陷：<br>
1.对于payable 合约接受转账没办法再合约里记录是谁发过来多少币。<br>
2.由于ERC20 标准没有一个转账通知机制，很多ERC20代币误转到合约之后，再也没有办法把币转移出来，已经有大量的ERC20 因为这个原因被锁死。<br>
3.ERC20 转账时，无法携带额外的信息。<br>
当然对于使用ERC-20开发的defi业务。我们可以通过采用两个交易组合完成。方法是：第1步：先让用户把要转移的金额用 ERC20 的approve 授权的存币的合约（这步通常称为解锁），第2步：再次让用户调用存币合约的函数，合约中使用mapping来记录转入的代币数量和转入地址。通过 transferFrom 把代币从用户手里转移的合约内。<br>
ERC777很好的解决了这些问题，同时ERC777 也兼容 ERC20 标准。<br>
ERC777 在 ERC20的基础上定义了 send(dest, value, data) 来转移代币， send函数额外的参数用来携带其他的信息，send函数会检查持有者和接收者是否实现了相应的钩子函数，如果有实现（不管是普通用户地址还是合约地址都可以实现钩子函数），则调用相应的钩子函数。</p>
<h1 id="erc1820-接口注册表合约">ERC1820 接口注册表合约</h1>
<p>即便是一个普通用户地址，同样可以实现对 ERC777 转账的监听， 听起来有点神奇，其实这是通过 ERC1820 接口注册表合约来是实现的。RC1820标准定义了一个通用注册表合约，任何地址（合约或普通用户帐户）都可以注册它支持的接口以及哪个智能合约负责接口实现。并且任何人都可以查询此注册表，询问哪个地址是否实现了给定的接口以及哪个智能合约处理实现逻辑。<br>
ERC1820注册表合约可以部署在任何链上，并在所有链上的地址是相同的。有一个唯一在以太坊链上都相同的合约地址，它总是0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24。接口的后28个字节都为0的话，会认为是 ERC165 接口，并且注册表将转发到合约以查看是否实现了接口。此合约还充当 ERC165 缓存，以减少 gas 消耗。<br>
ERC1820合约提过了两个主要接口：</p>
<pre><code class="language-setInterfaceImplementer(address">用来设置地址（_addr）的接口（_interfaceHash 接口名称的 keccak256 ）由哪个合约实现（_implementer）。
getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address)
这个函数用来查询地址（_addr）的接口由哪个合约实现。
</code></pre>
<p>setInterfaceImplementer函数会参数信息记录到下面这个interfaces映射里：</p>
<pre><code class="language-//">mapping(address =&gt; mapping(bytes32 =&gt; address)) interfaces;
</code></pre>
<p>相对应的 getInterfaceImplementer() 通过 interfaces 这个mapping 来获得接口的实现。<br>
ERC777 使用 send转账时会分别在持有者和接收者地址上使用ERC1820 的getInterfaceImplementer函数进行查询，查看是否有对应的实现合约，ERC777 标准规范里预定了接口及函数名称，如果有实现则进行相应的调用。</p>
<h1 id="erc777-标准规范">ERC777 标准规范</h1>
<h2 id="erc777-接口">ERC777 接口</h2>
<p>ERC777 为了在实现上可以兼容ERC20，除了查询函数和ERC20一致外，操作接口均采用的独立的命名（避免相同的命令无法分辨是哪个标准），ERC777的接口定义如下，要求所有的ERC777代币合约都必须实现这些接口：</p>
<pre><code class="language-interface">    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function balanceOf(address holder) external view returns (uint256);

    // 定义代币最小的划分粒度
    function granularity() external view returns (uint256);

    // 操作员 相关的操作（操作员是可以代表持有者发送和销毁代币的账号地址）
    function defaultOperators() external view returns (address[] memory);
    function isOperatorFor(
        address operator,
        address holder
    ) external view returns (bool);
    function authorizeOperator(address operator) external;
    function revokeOperator(address operator) external;

    // 发送代币
    function send(address to, uint256 amount, bytes calldata data) external;
    function operatorSend(
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    // 销毁代币
    function burn(uint256 amount, bytes calldata data) external;
    function operatorBurn(
        address from,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    // 发送代币事件
    event Sent(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    // 铸币事件
    event Minted(
        address indexed operator,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    // 销毁代币事件
    event Burned(
        address indexed operator,
        address indexed from,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    // 授权操作员事件
    event AuthorizedOperator(
        address indexed operator,
        address indexed holder
    );

    // 撤销操作员事件
    event RevokedOperator(address indexed operator, address indexed holder);
}
</code></pre>
<h2 id="接口说明与实现约定">接口说明与实现约定</h2>
<p>ERC777 合约必须要通过 ERC1820 注册 ERC777Token 接口，这样任何人都可以查询合约是否是ERC777标准的合约，注册方法是: 调用ERC1820 注册合约的 setInterfaceImplementer 方法，参数 _addr 及 _implementer 均是合约的地址，_interfaceHash 是 ERC777Token 的 keccak256 哈希值（0xac7fbab5...177054）<br>
如果 ERC777 要实现ERC20标准，还必须通过ERC1820 注册ERC20Token接口。</p>
<h2 id="erc777-信息说明函数">ERC777 信息说明函数</h2>
<p>name()，symbol()，totalSupply()，balanceOf(address) 和含义和在ERC20 中完全一样。<br>
granularity() 用来定义代币最小的划分粒度（&gt;=1）， 要求必须在创建时设定，之后不可以更改，不管是在铸币、发送还是销毁操作的代币数量，必需是粒度的整数倍。</p>
<pre><code class="language-granularity"></code></pre>
<h2 id="操作员">操作员</h2>
<p>ERC777 定义了一个新的操作员角色，操作员被作为移动代币的地址。 每个地址直观地移动自己的代币，将持有人和操作员的概念分开可以提供更大的灵活性。此外，ERC777还可以定义默认操作员（默认操作员列表只能在代币创建时定义的，并且不能更改），默认操作员是被所有持有人授权的操作员，这可以为项目方管理代币带来方便，当然认何持有人仍然有权撤销默认操作员。<br>
<code>与ERC20中的 approve 、 transferFrom 不同，其未明确定义批准地址的角色。</code></p>
<h3 id="操作员相关的函数">操作员相关的函数</h3>
<p>1.defaultOperators(): 获取代币合约默认的操作员列表.<br>
2.authorizeOperator(address operator): 设置一个地址作为msg.sender 的操作员，需要触发AuthorizedOperator事件。<br>
3.revokeOperator(address operator): 移除 msg.sender 上 operator 操作员的权限， 需要触发RevokedOperator事件。<br>
4.isOperatorFor(address operator, address holder)： 是否是某个持有者的操作员。</p>
<h2 id="发送代币">发送代币</h2>
<p>ERC777 发送代币 使用以下两个方法：</p>
<pre><code class="language-send(address">
function operatorSend(
    address from,
    address to,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
</code></pre>
<p>operatorSend 可以通过参数operatorData携带操作者的信息，发送代币除了执行对应账户的余额加减和触发事件之外，还有额外的规定：<br>
1.如果持有者有通过 ERC1820 注册 ERC777TokensSender 实现接口， 代币合约必须调用其 tokensToSend 钩子函数。<br>
2.如果接收者有通过 ERC1820 注册 ERC777TokensRecipient 实现接口， 代币合约必须调用其 tokensReceived 钩子函数。<br>
3.如果有 tokensToSend 钩子函数，必须在修改余额状态之前调用。<br>
4.如果有 tokensReceived 钩子函数，必须在修改余额状态之后调用。<br>
5.调用钩子函数及触发事件时， data 和 operatorData必须原样传递，因为 tokensToSend 和 tokensReceived 函数可能根据这个数据取消转账（触发 revert）。<br>
6.其中data和operatorData都属于calldata类型。一般只有外部函数的参数（不包括返回参数）被强制指定为calldata。这种数据位置是只读的，不会持久化到区块链。</p>
<h2 id="erc777tokenssender-接口定义">ERC777TokensSender 接口定义</h2>
<p>如果持有者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 ERC777TokensSender 接口。有一个地方需要注意: 对于所有的 ERC777 合约， 一个持有者地址只能注册一个ERC777TokensSender接口实现。因此 ERC777TokensSender 实现会被多个ERC777合约调用，在ERC777TokensSender接口的实现合约里， msg.sender 是ERC777合约地址，而不是操作者。</p>
<pre><code class="language-interface">    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}
</code></pre>
<h2 id="erc777tokensrecipient-接口定义">ERC777TokensRecipient 接口定义</h2>
<p>如果接收者希望在转账时收到代币转移通知，就需要在ERC1820合约上注册及实现 ERC777TokensRecipient 接口。<br>
如果接收者是一个合约地址， 则必须要注册及实现 ERC777TokensRecipient 接口（这样可以防止代币被锁死），如果没有实现，ERC777代币合约必须revert 回退交易状态。</p>
<pre><code class="language-interface">    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;
}
</code></pre>
<h1 id="铸币与销毁">铸币与销毁</h1>
<p>铸币（挖矿）是产生新币的过程，销毁代币则相反，在ERC20 中，没有明确定义这两个行为，通常会transfer方法和Transfer事件来表达。<br>
ERC777 则定义了代币从铸币、转移到销毁的整个生命周期。<br>
ERC777 没有定义铸币的方法名，只定义了 Minted事件，因为很多代币，是在创建的时候就确定好代币的数量。<br>
如果有需要合约可以自己定义铸币函数，铸币函数在实现时要求：<br>
1.必须触发Burned事件。<br>
2.总供应量必须减少代币销毁量， 持有者的余额必须减少代币销毁的数量。<br>
3.如果持有者通过ERC1820注册ERC777TokensSender 实现，必须调用持有者的tokensToSend钩子函数。</p>
<h1 id="erc777-代币实现">ERC777 代币实现</h1>
<p>OpenZeppelin 实现了一个 ERC777 基础合约，要实现自己的ERC777代币只需要继承 OpenZeppelin ERC777。<br>
实现主要是两步：通过基类ERC777的构造函数确认代币名称、代号以及默认操作员（可为空），然后调用 _mint 初始化发行量，注意发行量的小数位是固定的18位（和ether保持一致），在合约内部是按小数位保存的，因此发行的币数需要乘上10^18。</p>
<pre><code class="language-import">
contract MyERC777 is ERC777 {
    constructor(
        address[] memory defaultOperators
    )
        ERC777(&quot;MyERC777&quot;, &quot;LBC7&quot;, defaultOperators)
        public
    {
        uint initialSupply = 2100 * 10 ** 18;
        _mint(msg.sender, msg.sender, initialSupply, &quot;&quot;, &quot;&quot;);
    }
}
</code></pre>
<h1 id="监听代币收款">监听代币收款</h1>
<p>如果我们要为一个合约监听它的代币接受。我们可以在合约种继承IERC777Recipient来实现钩子函数：<br>
其中要注意：<br>
1.实例IERC1820Registry合约地址是一个唯一地址，全网统一。<br>
2.TOKENS_RECIPIENT_INTERFACE_HASH是ERC777TokensRecipient的哈希值，是一个固定值。<br>
3.setInterfaceImplementer设置回调的时候第一个地址为监听地址。第二个为监听合约实现地址。<br>
在回调种我们可以对转账进行记录或者处理账本或者黑白名单等操作。</p>
<pre><code class="language-import">import &quot;@openzeppelin/contracts/token/ERC777/IERC777.sol&quot;;
import &quot;@openzeppelin/contracts/introspection/IERC1820Registry.sol&quot;;

contract Merit is IERC777Recipient {

  mapping(address =&gt; uint) public givers;
  address _owner;
  IERC777 _token;

  IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);

  // keccak256(&quot;ERC777TokensRecipient&quot;)
  bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =
      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;

  constructor(IERC777 token) public {
    _erc1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));
    _owner = msg.sender;
    _token = token;
  }

// 收款时被回调
  function tokensReceived(
      address operator,
      address from,
      address to,
      uint amount,
      bytes calldata userData,
      bytes calldata operatorData
  ) external {
    givers[from] += amount;
  }
  }
</code></pre>
<h1 id="普通账户地址监听代币转出">普通账户地址监听代币转出</h1>
<p>当然我们除了为合约地址监听代币转入转出以外，也可以为账户地址来监听代币转出。监听代币的转出可以让持有者对发出去的代币有更多的控制，例如持有者可以设置一些黑名单，禁止操作员对黑名单内账号转账。<br>
根据 ERC1820 标准，只有账号的管理者才可以为账号注册接口实现合约，<br>
如果一个合约要为某个地址（或自身）实现某个接口， 则需要实现下面这个接口:</p>
<pre><code class="language-interface">    /// @notice 指示合约是否为地址 “addr” 实现接口 “interfaceHash”。
    /// @param interfaceHash 接口名称的 keccak256 哈希值
    /// @param addr 为哪一个地址实现接口
    /// @return 只有当合约为地址'addr'实现'interfaceHash'时返回 ERC1820_ACCEPT_MAGIC
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}
</code></pre>
<p>通过在 canImplementInterfaceForAddress 返回 ERC1820_ACCEPT_MAGIC 以声明实现了 interfaceHash 对应的接口。在调用ERC1820的 setInterfaceImplementer 函数设置接口实现时，会通过 canImplementInterfaceForAddress 检查合约时候实现了接口。</p>
<pre><code class="language-import">import &quot;@openzeppelin/contracts/token/ERC777/IERC777.sol&quot;;
import &quot;@openzeppelin/contracts/introspection/IERC1820Registry.sol&quot;;
import &quot;@openzeppelin/contracts/introspection/IERC1820Implementer.sol&quot;;


contract SenderControl is IERC777Sender, IERC1820Implementer {

  IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
  bytes32 constant private ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(&quot;ERC1820_ACCEPT_MAGIC&quot;));

  //    keccak256(&quot;ERC777TokensSender&quot;)
  bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =
        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;

  mapping(address =&gt; bool) blacklist;
  address _owner;

  constructor() public {
    _owner = msg.sender;
  }

function setInterfaceImp(address userAddress) public {
_erc1820.setInterfaceImplementer(userAddress, TOKENS_RECIPIENT_INTERFACE_HASH, address(this));
}

  //  account call erc1820.setInterfaceImplementer
  function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32) {
    if (interfaceHash == TOKENS_SENDER_INTERFACE_HASH) {
      return ERC1820_ACCEPT_MAGIC;
    } else {
      return bytes32(0x00);
    }
  }

  function setBlack(address account, bool b) external {
    require(msg.sender == _owner, &quot;no premission&quot;);
    blacklist[account] = b;
  }

  function tokensToSend(
      address operator,
      address from,
      address to,
      uint amount,
      bytes calldata userData,
      bytes calldata operatorData
  ) external {
    if (blacklist[to]) {
      revert(&quot;ohh... on blacklist&quot;);
    }
  }

}
</code></pre>
<p>给发送者账号(假设为A）设置代理合约的方法为：先部署代理合约，获得代理合约地址， 然后用A账号去调用 ERC1820 的 setInterfaceImplementer函数，参数分别是 A的地址、接口的 keccak256 即0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895 以及 代理合约地址。</p>
<h1 id="openzeppelin-erc-777-源码分析">openzeppelin ERC-777 源码分析</h1>
<p>在openzeppelin/constracts中erc-777主要有一下4个文件：<br>
1.ERC777.sol: 协议具体的逻辑实现。<br>
2.IERC777.sol: 对外提供的接口。<br>
3.IERC777Recipient.sol：监听接受代币回调接口。<br>
4.IERC777Sender.sol: 监听发送代币回调接口。<br>
我们主要review一下 ERC777.sol：<br>
首先ERC777继承了 IERC777 和 IERC20接口：<br>
<code>contract ERC777 is Context, IERC777, IERC20 {</code><br>
所以erc777 合约逻辑是完全兼容ERC20协议的。在ERC-20的基础上增加了以下属性：</p>
<pre><code class="language-bytes32">    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(&quot;ERC777TokensRecipient&quot;);

    //操作员数组
    address[] private _defaultOperatorsArray;

    // 操作员权限映射
    mapping(address =&gt; bool) private _defaultOperators;

    //每个操作员地址对应的每个合约地址权限的映射，以及撤销的映射。
    mapping(address =&gt; mapping(address =&gt; bool)) private _operators;
    mapping(address =&gt; mapping(address =&gt; bool)) private _revokedDefaultOperators;
</code></pre>
<p>在构造函数中遍历默认操作员数组，并且将操作员权限初始化。然后向ERC1820合约注册&quot;ERC777&quot;和&quot;ERC20&quot;接口：</p>
<pre><code class="language-constructor(">        string memory name_,
        string memory symbol_,
        address[] memory defaultOperators_
    ) {
        _name = name_;
        _symbol = symbol_;

        _defaultOperatorsArray = defaultOperators_;
        for (uint256 i = 0; i &lt; defaultOperators_.length; i++) {
            _defaultOperators[defaultOperators_[i]] = true;
        }

        // register interfaces
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(&quot;ERC777Token&quot;), address(this));
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(&quot;ERC20Token&quot;), address(this));
    }
</code></pre>
<p>ERC-777保留了ERC-20的tranform函数，并且增加了_send 发送方法：</p>
<pre><code class="language-function">        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData,
        bool requireReceptionAck
    ) internal virtual {
        require(from != address(0), &quot;ERC777: send from the zero address&quot;);
        require(to != address(0), &quot;ERC777: send to the zero address&quot;);

        address operator = _msgSender();

        _callTokensToSend(operator, from, to, amount, userData, operatorData);

        _move(operator, from, to, amount, userData, operatorData);

        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);
    }
    ```
    在调用发送_move发送代币之前，调用了_callTokensToSend 用来回调注册的监听发送代币的回调函数。在发送代币之后调用了监听接受代币的回调函数。
    _callTokensToSend和_callTokensReceived的实现类似：
```    function _callTokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    ) private {
        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);
        if (implementer != address(0)) {
            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);
        }
    }
</code></pre>
<p>首先通过_ERC1820_REGISTRY.getInterfaceImplementer向对应的地址获取是否注册了监听。并且调用相应地址的回调函数：<br>
IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ERC-721]]></title>
        <id>https://tangminjie.github.io/post/erc-721/</id>
        <link href="https://tangminjie.github.io/post/erc-721/">
        </link>
        <updated>2022-04-21T08:43:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>什么是非同质化代币？<br>
非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！</p>
<h1 id="erc-721-是什么">ERC-721 是什么?</h1>
<p>和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs。<br>
那怎么理解非同质代币呢?ERC20代币是可置换的，且可细分为N份（1 = 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。所以每一个erc721的token都是独一无二的。</p>
<h1 id="erc721标准">ERC721标准</h1>
<p>ERC721作为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下：</p>
<pre><code class="language-pragma">
interface ERC721 /* is ERC165 */ {
    
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    //返回由_owner持有的NFTs的数量
    function balanceOf(address _owner) external view returns (uint256);
    //返回tokenid代币持有者的地址
    function ownerOf(uint256 _tokenId) external view returns (address);

    //转移NFT所有权，一次成功的转移操作必须发起 Transer 事件
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
    //transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;

    //授予地址_approved具有_tokenId的控制权，方法成功后需触发Approval 事件
    function approve(address _approved, uint256 _tokenId) external payable;
    //授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。
    function setApprovalForAll(address _operator, bool _approved) external;
    //用来查询某个tokenid的授权。
    function getApproved(uint256 _tokenId) external view returns (address);
    //查询_owner 对 _operator是否所有授权
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}
</code></pre>
<p>其中我们需要特别注意 safeTransferFrom(): 的用法：<br>
safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：<br>
1.调用者msg.sender应该是当前tokenId的所有者或被授权的地址<br>
2._from 必须是 _tokenId的所有者<br>
3._tokenId 应该是当前合约正在监测的NFTs 中的任何一个<br>
4._to 地址不应该为 0<br>
5.如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为<code>bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))抛出异常。</code><br>
一个可接收NFT的合约必须实现ERC721TokenReceiver接口：</p>
<pre><code class="language-interface">        /// @return `bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))`
        function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);
    }
</code></pre>
<p>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</p>
<h1 id="erc165-标准">ERC165 标准</h1>
<p>ERC721标准同时要求必须符合ERC165标准 ，其接口如下：</p>
<pre><code class="language-interface">    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
</code></pre>
<p>ERC165同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。<br>
interfaceID为函数选择器，计算方式有两种，如：bytes4(keccak256('supportsInterface(bytes4)'));或ERC165.supportsInterface.selector，多个函数的接口ID为函数选择器的异或值。</p>
<h1 id="可选实现接口erc721metadata">可选实现接口：ERC721Metadata</h1>
<p>ERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。<br>
其接口定义如下：</p>
<pre><code class="language-interface">    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function tokenURI(uint256 _tokenId) external view returns (string);
}
</code></pre>
<p>接口说明：<br>
1.name(): 返回合约名字，尽管是可选，但强烈建议实现，即便是返回空字符串。<br>
2.symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。<br>
3.tokenURI(): 返回_tokenId所对应的外部资源文件的URI（通常是IPFS或HTTP(S)路径）。外部资源文件需要包含名字、描述、图片，其格式的要求如下：</p>
<pre><code class="language-{">    &quot;title&quot;: &quot;Asset Metadata&quot;,
permalink: token-erc721
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
        &quot;name&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Identifies the asset to which this NFT represents&quot;,
        },
        &quot;description&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Describes the asset to which this NFT represents&quot;,
        },
        &quot;image&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.&quot;,
        }
    }
}
</code></pre>
<p>tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。</p>
<h1 id="可选实现接口erc721enumerable">可选实现接口：ERC721Enumerable</h1>
<p>ERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下：</p>
<pre><code class="language-interface">    function totalSupply() external view returns (uint256);
    function tokenByIndex(uint256 _index) external view returns (uint256);
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
}
</code></pre>
<p>接口说明：<br>
1.totalSupply(): 返回NFT总量<br>
2.tokenByIndex(): 通过索引返回对应的tokenId。<br>
3.tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。</p>
<h1 id="补充说明">补充说明</h1>
<h2 id="ntf-ids">NTF IDs</h2>
<p>NTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有：<br>
1.从0开始，每新加一个NFT，NTF ID加1<br>
2.使用sha3后uuid 转换为 NTF ID</p>
<h2 id="与erc-20的兼容性">与ERC-20的兼容性</h2>
<p>ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。</p>
<h2 id="交易-挖矿-销毁">交易、挖矿、销毁</h2>
<p>在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。</p>
<h1 id="openzeppelin-中-erc-721的实现">openzeppelin 中 ERC-721的实现</h1>
<p>在@openzeppelin/constracts/erc721.sol中实现了erc721的标准。<br>
ERC721合约继承了 Context, 抽象合约，ERC165, IERC721, IERC721Metadata接口合约。<br>
<code>contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {</code><br>
1.Context 抽象合约提供了有关当前执行上下文的信息，包括事务的发送者及其数据。可以调用获得msg.sender 地址。<br>
2.ERC165 提供了supportsInterface 接口。可以通过type(IERC721).interfaceId来查询合约实现了哪些接口。<br>
3.IERC721，erc721的标准接口。<br>
4.IERC721Metadata提供了合约的元数据接口，包括nfttoken的name，symbol，tokenUrl。<br>
并且相对于ERC20 _mint接口需要提供 tokenid 并且增加了_setTokenURI接口将tokenID和tokenUrl绑定。tokenUrl通常为IPFS地址或者HTTPS地址。</p>
<h2 id="构建-erc721-代币合约">构建 ERC721 代币合约</h2>
<pre><code class="language-//">// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;
import &quot;@openzeppelin/contracts/utils/Counters.sol&quot;;

contract GameItem is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() public ERC721(&quot;GameItem&quot;, &quot;ITM&quot;) {}

    function awardItem(address player, string memory tokenURI)
        public
        returns (uint256)
    {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }
}
</code></pre>
<p>ERC721合同包括所有标准扩展（和IERC721Metadata）IERC721Enumerable。这就是该_setTokenURI方法的来源：我们使用它来存储项目的元数据。<br>
另请注意，与 ERC20 不同，ERC721 缺少decimals字段，因为每个令牌都是不同的并且不能被分区。</p>
<pre><code class="language-可以创建新项目：">
&gt; gameItem.awardItem(playerAddress, &quot;https://game.example/item-id-8u5h2m.json&quot;)
Transaction successful. Transaction hash: 0x...
Events emitted:
 - Transfer(0x0000000000000000000000000000000000000000, playerAddress, 7)
以及查询到的每个项目的所有者和元数据：

&gt; gameItem.ownerOf(7)
playerAddress
&gt; gameItem.tokenURI(7)
&quot;https://game.example/item-id-8u5h2m.json&quot;
这tokenURI应该解析为可能类似于以下内容的 JSON 文档：

{
    &quot;name&quot;: &quot;Thor's hammer&quot;,
    &quot;description&quot;: &quot;Mjölnir, the legendary hammer of the Norse god of thunder.&quot;,
    &quot;image&quot;: &quot;https://game.example/item-id-8u5h2m.png&quot;,
    &quot;strength&quot;: 20
}
</code></pre>
<p>您会注意到该项目的信息包含在元数据中，但该信息不在链上！所以游戏开发者可以改变底层元数据，改变游戏规则！如果你想把所有的物品信息放在链上，你可以扩展 ERC721 来这样做（虽然它会相当昂贵）。您还可以利用 IPFS 来存储 tokenURI 信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ERC-20]]></title>
        <id>https://tangminjie.github.io/post/erc-20/</id>
        <link href="https://tangminjie.github.io/post/erc-20/">
        </link>
        <updated>2022-04-20T07:03:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="概述">概述</h1>
<p>ERC-20 提供了一个同质化代币的标准，换句话说，每个代币与另一个代币（在类型和价值上）完全相同。 例如，一个 ERC-20 代币就像 ETH 一样，意味着一个代币会并永远会与其他代币一样。<br>
ERC20简单理解成以太坊上的一个代币协议，所有基于以太坊开发的代币合约都遵守这个协议。遵守这些协议的代币我们可以认为是标准化的代币，而标准化带来的好处是兼容性好。这些标准化的代币可以被各种以太坊钱包支持，用于不同的平台和项目。</p>
<h1 id="erc20协议标准">ERC20协议标准</h1>
<p>ERC20标准规定，一共包括：6个函数，2个event，3个变量。</p>
<pre><code class="language-contract">    //查询代币发行总量
  	function totalSupply() public constant returns (uint);  
      //查询某个账户余额
  	function balanceOf(address tokenOwner) public constant returns (uint balance);
      //查询某个账户可转账金额。用于控制代币的交易
   	function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
       //从当前账户，实现代币交易
 	function transfer(address to, uint tokens) public returns (bool success); 
     //授权，允许某个账户花费此地址可用的代币数
  	function approve(address spender, uint tokens) public returns (bool success); 
      //实现用户之间的代币交易
  	function transferFrom(address from, address to, uint tokens) public returns (bool success);
     //当代币交易时会触发此函数
  	event Transfer(address indexed from, address indexed to, uint tokens);  
     //当成功调用approve函数后会触发此函数
  	event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    string public constant name = &quot;Zarten Token&quot;; //代币名称
    string public constant symbol = &quot;ZAR&quot;;              //代币简称
    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places
    // 0.0000000000000000001  个代币
    //返回token使用的小数点后几位。比如设置为3,就是支持0.001表示。一般为18位
}
</code></pre>
<h1 id="erc20工作原理">ERC20工作原理</h1>
<h2 id="变量及函数实现">变量及函数实现</h2>
<h3 id="定义变量">定义变量</h3>
<p>一般定义两个映射变量：保存每个地址对应的余额。<br>
<code>mapping (address =&gt; uint256) public balances</code><br>
两层映射。保存着某个地址A允许另一个地址B可操作的金额。最外层映射为某个地址A，内层映射为另一个地址B，值为可操作（发起交易）金额总量。<br>
<code>mapping(address =&gt; mapping(address =&gt;uint256)) public allowed</code></p>
<h2 id="函数实现">函数实现</h2>
<h3 id="balanceof">balanceOf()</h3>
<p>从映射变量balances中取出某个地址的余额。</p>
<pre><code class="language-function">       return balances[tokenOwner];
}
</code></pre>
<h3 id="transfer">transfer()</h3>
<p>当前账户转账操作。<br>
msg.sender为保留字，指这个函数的地址。<br>
sub：减 add：加<br>
首先从当前账户减去相应金额。<br>
同时往对方账户加上对应金额。<br>
并调用Transfer函数做通知。</p>
<pre><code class="language-function">    balances[msg.sender] = balances[msg.sender].sub(tokens);
    balances[to] = balances[to].add(tokens);
    Transfer(msg.sender, to, tokens);
    return true;
}
</code></pre>
<h3 id="transferfrom">transferFrom()</h3>
<p>用户之间账户转账操作。由from地址发起转账交易。<br>
from地址账户减去相应金额。<br>
from从msg.sender总共可操作金额减少相应金额。<br>
to地址账户增加相应金额。<br>
调用Transfer函数做通知。<br>
approve后可以转移对方代币给自己</p>
<pre><code class="language-function">        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        Transfer(from, to, tokens);
        return true;
 }
</code></pre>
<h3 id="approve">approve()</h3>
<p>设置某账户spender可操控msg.sender的代币数。<br>
设置spender地址从msg.sender可使用的代币数。<br>
调用Approval函数做通知。</p>
<pre><code class="language-function">        allowed[msg.sender][spender] = tokens;
        Approval(msg.sender, spender, tokens);
        return true;
 }
</code></pre>
<h1 id="erc20高级功能代码">ERC20高级功能代码</h1>
<p>ERC20代币有时需要其他一些额外的高级功能，比如代币管理、代币增发、空投代币、代币冻结、销毁代币、代币兑换等。</p>
<h2 id="代币管理">代币管理</h2>
<p>有时代币需要有一个管理者功能。使用onlyOwner修饰的接口只能有合约所有者调用，否则会抛出异常。<br>
添加一个owned合约，如下：</p>
<pre><code class="language-contract">    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
</code></pre>
<h2 id="代币增发">代币增发</h2>
<p>代币增发可使代币总供应量增加，可以指定某个账户的代币增加，同时总供应量也随之增加。<br>
使用onlyOwner修饰器，只能owner调用。this表示当前合约。</p>
<pre><code class="language-function">        balances[target] += mintedAmount;
        _totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
</code></pre>
<h2 id="代币销毁">代币销毁</h2>
<p>首先添加一个通知客户端代币消费的事件。</p>
<pre><code class="language-event"></code></pre>
<p>销毁代币非为销毁管理者代币和销毁用户代币。此时需要管理者去进行销毁。</p>
<h2 id="销毁管理者代币">销毁管理者代币</h2>
<pre><code class="language-function">        require(balances[owner] &gt;= _value);
        balances[owner] -= _value;
        _totalSupply -= _value;
        emit Burn(owner, _value);
        return true;
    }
</code></pre>
<h2 id="销毁用户代币">销毁用户代币</h2>
<p>销毁之前需要判断用户代币的数量是否大于销毁数量，并且判断allowed可以使用的代币大于需要销毁的代币数量。</p>
<pre><code class="language-function">        require(balances[_from] &gt;= _value);
        require(_value &lt;= allowed[_from][owner]);
        balances[_from] -= _value;
        allowed[_from][owner] -= _value;
        _totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
</code></pre>
<h2 id="代币冻结">代币冻结</h2>
<p>有时需要冻结账户代币，也就是此账户不能转账操作。<br>
1.首先添加一个账户冻结代币的映射<br>
<code>mapping (address =&gt; bool) public frozenAccount;</code><br>
2.添加冻结的通知函数<br>
<code>event FrozenFunds(address target, bool frozen);</code><br>
3..添加冻结的函数</p>
<pre><code class="language-function">        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
</code></pre>
<p>4.在转账函数中判断涉及账户是否为冻结账户，否则不允许转账操作</p>
<pre><code class="language-require(!frozenAccount[from]);">require(!frozenAccount[to]);
</code></pre>
<h2 id="批量代币空投">批量代币空投</h2>
<p>有时需要往很多地址空投一些代币，这样可以使用批量转账。<br>
假设从管理员账户空投。关键字memory为声明内存型的，存储的内容会在函数被调用（包括外部函数）时擦除，所以其使用开销相对较小。</p>
<pre><code class="language-//空投代币">    function AirDrop(address[] memory _recipients, uint _values) onlyOwner public returns (bool) {
        require(_recipients.length &gt; 0);

        for(uint j = 0; j &lt; _recipients.length; j++){
            transfer(_recipients[j], _values);
        }

        return true;
    }
</code></pre>
<p>当然在实际应用中空投的数量并不是绝对的，大部分业务根据持有的代币比例或者NFT来计算空投。</p>
<h2 id="代币兑换">代币兑换</h2>
<p>有时代币需要与其他货币（Ether）进行兑换。<br>
msg.value表示随消息发送的wei的数量，payable修饰函数表示允许从调用中接收以太币。<br>
1.设置买卖价格的变量</p>
<pre><code class="language-uint256">uint256 public buyPrice;
</code></pre>
<p>2.设置价格函数</p>
<pre><code class="language-function">        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
</code></pre>
<p>3.接收以太币进行买操作</p>
<pre><code class="language-function">        uint amount = msg.value / buyPrice;
        emit Transfer(address(this), owner, amount);
    }
</code></pre>
<p>4.卖操作</p>
<pre><code class="language-function">        require(address(this).balance &gt;= amount * sellPrice);
        emit Transfer(owner, address(this), amount);
        owner.transfer(amount * sellPrice);
    }
</code></pre>
<p>当然在实际应用中的价格由dex或者uniswap等去中心化交易所，通过AMM协议的交易对计算得出。</p>
<h1 id="openzeppelin-erc-20实现">openzeppelin ERC-20实现</h1>
<p>我们在写合约业务的时候可以选择自己实现ERC20的协议，当然也可以使用openzeppelin的第三方库。openzeppelin中有完善的ERC20实现。<br>
首先我们来看下一下openzeppelin官方文档中对于ERC20的描述：<br>
ERC20 代币合约跟踪可替代代币：任何一种代币都完全等同于任何其他代币；没有任何代币具有与之相关的特殊权利或行为。这使得 ERC20 代币可用于交换货币、投票权、质押等媒介。<br>
使用openzeppelin来构建erc20-token也十分的方便：<br>
我们在hardhat工程中通过 npm install @openzeppelin/contracts 来安装openzeppelin的支持，就可以import进来使用：<br>
我们的合约经常通过继承使用，在这里我们将重用ERC20基本标准实现以及name,symbol和decimals可选扩展。此外，我们正在创建一个initialSupply令牌，它将分配给部署合约的地址。</p>
<pre><code class="language-pragma">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;
contract GLDToken is ERC20 {
    constructor(uint256 initialSupply) public ERC20(&quot;Gold&quot;, &quot;GLD&quot;) {
        _mint(msg.sender, initialSupply);
    }
}
</code></pre>
<p>就是这样！部署后，我们将能够查询部署者的余额：</p>
<pre><code>&gt; GLDToken.balanceOf(deployerAddress)
1000000000000000000000
我们也可以将这些代币转移到其他账户：

&gt; GLDToken.transfer(otherAddress, 300000000000000000000)
&gt; GLDToken.balanceOf(otherAddress)
300000000000000000000
&gt; GLDToken.balanceOf(deployerAddress)
700000000000000000000
</code></pre>
<h2 id="关于decimals">关于decimals</h2>
<p>通常，您希望能够将您的代币分成任意数量：例如，如果您拥有5 GLD，您可能想发送1.5 GLD给朋友，并留给3.5 GLD自己。不幸的是，Solidity 和 EVM 不支持这种行为：只能使用整数（整数）。为了解决这个问题，ERC20提供了一个decimals字段，用于指定令牌有多少个小数位。为了能够转移1.5 GLD，decimals必须至少1，因为该数字有一个小数位。就像ETH的最小单位是wei。1eth = 10^18wei。<br>
在openzeppelin中默认情况下，ERC20使用值18for decimals。要使用不同的值，您需要在构造函数中调用_setupDecimals。<br>
因此，如果您想5使用 18 位小数的代币合约发送代币，调用的方法实际上是：<br>
<code>transfer(recipient, 5 * 10^18);</code></p>
]]></content>
    </entry>
</feed>